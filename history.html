<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="color-scheme" content="only light">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#ffffff">
    <title>GymNerd | History</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,300,0,0" rel="stylesheet">
    <script src="auth.js"></script>
    <script src="gn-i18n.js"></script>
    <script src="drive-storage.js"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="db.js"></script>
    <link rel="stylesheet" href="styles/app-titles.css">
    <style>
        :root { --primary: #3b82f6; --primary-grad: linear-gradient(135deg, #60a5fa 0%, #2563eb 100%); --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --text-dim: #94a3b8; --success: #10b981; --danger: #ef4444; }
        body { font-family: system-ui, sans-serif; background: var(--bg); color: var(--text); max-width: 500px; margin: 0 auto; padding: 0; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        /* Top-card (same style used on index.html) */
        .top-card { position: static; background: linear-gradient(180deg, #ffffff 0%, #ffffff 70%, #f3f4f6 100%); color: #0f172a; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; padding: 10px 16px 6px; box-shadow: 0 6px 16px rgba(2,6,23,0.06); padding-top: calc(10px + constant(safe-area-inset-top)); padding-top: calc(10px + env(safe-area-inset-top)); }
        body::before { content: ''; position: fixed; top: 0; left: 0; right: 0; height: constant(safe-area-inset-top); height: env(safe-area-inset-top); background: #ffffff; z-index: 1100; pointer-events: none; }
        .top-card-inner { max-width: 100%; display:flex; flex-direction:column; align-items:center; gap:8px; padding-bottom: 2px; }
        .app-title-compact, .top-title { margin: 20px 0; }
        .page-content { padding: 16px; padding-top: 8px; }
        .top-card .topbar { background: transparent; padding: 6px 0; display:flex; align-items:center; justify-content:space-between; width:100%; }
        #topbar-title { flex: 1; min-width: 0; display:flex; align-items:center; }
        
        .back-btn { text-decoration: none; font-size: 1.5rem; color: var(--bg); }
            /* Ensure back button icons are vertically centered inside top bars */
            .top-card .back-btn, .top-card .back-btn .material-symbols-outlined { display: inline-flex; align-items: center; justify-content: center; line-height: 1; }
        .card { background: var(--card); padding: 20px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.05); margin-bottom: 20px; }
        .card h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2rem; }
        select, input, button { padding: 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); font-size: 1rem; width: 100%; box-sizing: border-box; background: rgba(255,255,255,0.05); color: white; }
        /* Make native date picker calendar icon white on WebKit browsers (Safari, Chrome) */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1) brightness(2);
            cursor: pointer;
        }
        .exercise-row { background: var(--card); padding: 15px; border-radius: 12px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.05); display: grid; grid-template-columns: 50px 1fr 30px; gap: 15px; align-items: center; }
        .ex-thumb { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; background: #fff; }
        .log-entry img { background: #fff; }
        .input-pair { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 10px; grid-column: span 3; }
        .input-pair input { background: #000; }
        .save-session { background: var(--primary-grad); color: white; border: none; font-weight: bold; cursor: pointer; margin-top: 10px; box-shadow: 0 10px 20px rgba(37, 99, 235, 0.2); }
        button.primary { background: var(--primary-grad); color: white; border: none; font-weight: bold; cursor: pointer; }
        .save-session.success { background: var(--success); }

        details.history-section, .history-section { background: transparent; border-radius: 0; border: none; margin-top: 12px; }
        summary.section-header { font-weight: 800; cursor: pointer; padding: 15px 20px; list-style: none; display: flex; justify-content: space-between; align-items: center; color: var(--text-dim); }
        summary .chevron { transition: transform 0.2s; color: var(--text-dim); }
        details[open] summary .chevron { transform: rotate(180deg); }

        details.month-group { margin-bottom: 15px; }
        summary.month-header { font-weight: 700; font-size: 0.85rem; color: var(--text-dim); cursor: pointer; padding: 8px 0; list-style: none; text-transform: uppercase; letter-spacing: 0.05em; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.05); margin-bottom: 10px; }

        details.history-group { background: rgba(255,255,255,0.02); border-radius: 12px; border: 1px solid rgba(255,255,255,0.05); margin-bottom: 10px; overflow: hidden; }
        #history .history-group:first-child { margin-top: 16px; }
        summary.date-header { padding: 16px 15px; font-size: 0.85rem; font-weight: 800; cursor: pointer; list-style: none; display: flex; justify-content: space-between; align-items: center; }
        .log-entry { padding: 14px 15px; border-bottom: 1px solid rgba(255,255,255,0.02); display: flex; justify-content: space-between; align-items: flex-start; font-size: 0.85rem; color: var(--text-dim); }
        .log-entry .meta { display:flex; flex-direction:column; gap:6px; align-items:flex-start; }
        .log-entry .name-row { display:flex; align-items:center; gap:8px; font-weight:700; color:var(--text); }
        .log-entry .data-row { font-size:0.85rem; color:var(--text-dim); }
        .delete-btn { background:none; border:none; color:var(--danger); cursor:pointer; padding:8px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; width:40px; height:40px; touch-action:manipulation; opacity:0.9 }
        .delete-btn svg { width:18px; height:18px; }
        .edit-btn { background:none; border:none; color:var(--primary); cursor:pointer; padding:8px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; width:40px; height:40px; touch-action:manipulation; opacity:0.95 }
        .edit-btn svg { width:18px; height:18px; }
        .date-edit-btn { background:none; border:1px solid rgba(255,255,255,0.06); color:var(--primary); padding:8px 12px; border-radius:10px; cursor:pointer; }
        .date-header .delete-btn { margin-left:12px; margin-right:6px; opacity:0.8 }
        .log-entry { gap: 8px; }
        .date-delete-btn { background:none; border:1px solid rgba(255,255,255,0.06); color:var(--danger); padding:8px 12px; border-radius:10px; cursor:pointer; }
        /* Filter row styles */
        .filters-wrap { max-width:500px; margin: 20px auto 0; padding: 0 16px; }
        .filter-row { display:flex; gap:8px; padding:8px 6px; align-items:center; margin:6px 0 6px 0; }
        .filter-label { color:var(--text-dim); font-size:0.85rem; white-space:nowrap; }
        .filter-select { flex:1; max-width:160px; padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.03); color:var(--text); border:1px solid rgba(255,255,255,0.06); outline:none; }
        @media (max-width:420px) { .filter-row { flex-wrap:wrap; } .filter-select { max-width:100%; } }
        .empty-state { padding:12px; color:var(--text-dim); text-align:center; }
    </style>
</head>
<body>
    <script>
        (function(){
            try {
                const name = (location.pathname || '').split('/').pop() || '';
                if (name === 'history.html') {
                    const basePath = (location.pathname || '/').replace(/\/[^\/]*$/, '/') || '/';
                    const target = basePath + 'index.html?start=history';
                    try { location.replace(target); } catch(e) { location.href = target; }
                }
            } catch (e) {}
        })();
    </script>
    <div class="main-content">
    <div class="top-card">
        <div class="top-card-inner">
            <div style="display:flex;align-items:center;width:100%;gap:12px;">
                <div style="flex:1;min-width:0;">
                    <h2 class="app-title-compact" data-i18n="history_header">History</h2>
                </div>
                <button id="toggleRoutineForm" type="button" class="primary" style="margin-left:8px;padding:10px 14px;border-radius:10px;font-size:0.9rem;width:auto;min-width:0;white-space:nowrap;align-self:center;" data-i18n="history_btn_new_routine" onclick="location.href='historycrud.html?mode=routine'">New Routine Entry</button>
            </div>
        </div>
    </div>
    <div class="filters-wrap">
        <div class="filter-row">
            <label class="filter-label" for="filterMonth" data-i18n="filter_month">Month</label>
            <select id="filterMonth" class="filter-select"></select>
            <label class="filter-label" for="filterYear" data-i18n="filter_year">Year</label>
            <select id="filterYear" class="filter-select"></select>
        </div>
    </div>
    <div class="page-content">
    <div id="history" class="history-section">
        
    </div>

        <script>
                function formatDateDisplay(dateStr){
                    if (!dateStr) return dateStr;
                    const parts = dateStr.split('-');
                    if (parts.length !== 3) return dateStr;
                    // Return DD/MM/YY
                    return `${parts[2]}/${parts[1]}/${parts[0].slice(2)}`;
                }
        let allEx = [];

        async function init() {
            await ensureDbOpen();
            // Default images will use `defaultImage` defined in `db.js` when specific images are missing.
            const [catalogEx, customEx] = await Promise.all([
                db.catalog_exercises.toArray(),
                db.custom_exercises.toArray()
            ]);
            allEx = [
                ...catalogEx.map(ex => ({ ...ex, isCustom: false })),
                ...customEx.map(ex => ({ ...ex, isCustom: true }))
            ];
            renderHistory();
            // Allow only one open details at a time: when one `details.history-group` opens,
            // collapse all other `details.history-group` elements.
            const historyContainer = document.getElementById('history');
            if (historyContainer && !historyContainer._singleOpenListener) {
                historyContainer.addEventListener('toggle', function(e){
                    const opened = e.target;
                    if (!opened || !opened.classList || !opened.classList.contains('history-group')) return;
                    if (!opened.open) return; // only act when it was opened
                    const others = historyContainer.querySelectorAll('details.history-group');
                    others.forEach(d => { if (d !== opened) d.open = false; });
                }, true);
                historyContainer._singleOpenListener = true;
            }
        }

        function populateFilters(monthKeys) {
            // monthKeys: array of 'YYYY-MM' strings
            const monthSel = document.getElementById('filterMonth');
            const yearSel = document.getElementById('filterYear');
            if (!monthSel || !yearSel) return;
            // build min/max year from keys
            const years = new Set();
            monthKeys.forEach(k => { const y = k.split('-')[0]; if (y) years.add(y); });
            const yearArr = Array.from(years).sort((a,b)=>a-b);
            const current = new Date();
            const curYear = String(current.getFullYear());
            const curMonth = String(current.getMonth()+1).padStart(2,'0');

            // populate months (localized short names)
            if (monthSel.options.length === 0) {
                const lang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : (navigator.language || 'en');
                const locale = lang === 'pt' ? 'pt' : 'en';
                const monthNames = [];
                for (let i = 0; i < 12; i++) {
                    const dt = new Date(2020, i, 1);
                    monthNames.push(new Intl.DateTimeFormat(locale, { month: 'short' }).format(dt));
                }
                for (let i=1;i<=12;i++){
                    const val = String(i).padStart(2,'0');
                    const opt = document.createElement('option'); opt.value = val; opt.text = monthNames[i-1];
                    monthSel.appendChild(opt);
                }
            }

            // populate years if not already populated or if range changed
            // Ensure current year is available in the list and selected by default
            if (!yearArr.includes(curYear)) {
                yearArr.push(curYear);
                yearArr.sort((a,b)=>a-b);
            }
            if (yearSel.options.length === 0) {
                for (const y of yearArr) {
                    const opt = document.createElement('option'); opt.value = y; opt.text = y; yearSel.appendChild(opt);
                }
            }

            // Ensure current year option exists in the select even if options were already present
            if (!yearSel.querySelector(`option[value="${curYear}"]`)) {
                const opt = document.createElement('option'); opt.value = curYear; opt.text = curYear; yearSel.appendChild(opt);
                // sort options by value
                const opts = Array.from(yearSel.options).sort((a,b) => a.value.localeCompare(b.value));
                yearSel.innerHTML = '';
                opts.forEach(o => yearSel.appendChild(o));
            }

            // Pre-select current month/year on first initialization (preserve user selection afterwards)
            if (!monthSel._initialized) {
                try {
                    if (monthSel.querySelector(`option[value="${curMonth}"]`)) monthSel.value = curMonth;
                    else if (monthSel.options.length) monthSel.value = monthSel.options[0].value;
                } catch(e) {}
                monthSel._initialized = true;
            }

            if (!yearSel._initialized) {
                try { yearSel.value = yearArr.includes(curYear) ? curYear : (yearArr.length ? yearArr[yearArr.length-1] : curYear); } catch(e) {}
                yearSel._initialized = true;
            }

            // attach onchange listeners once
            if (!monthSel._listenerAttached) {
                monthSel.addEventListener('change', () => renderHistory());
                monthSel._listenerAttached = true;
            }
            if (!yearSel._listenerAttached) {
                yearSel.addEventListener('change', () => renderHistory());
                yearSel._listenerAttached = true;
            }

            // Ensure filters are translated if localization is available
            if (window.GN_I18N && typeof GN_I18N.applyTranslations === 'function') {
                try { GN_I18N.applyTranslations(document.querySelector('.filters-wrap') || document); } catch(e){}
            }
        }
        

        async function deleteDateLogs(date) {
            const fmt = formatDateDisplay(date);
            if (window.GN_I18N && typeof GN_I18N.t === 'function') {
                const tmpl = GN_I18N.t('history_confirm_delete');
                if (confirm(tmpl.replace('{date}', fmt))) {
                    await db.history.where('date').equals(date).delete();
                    localStorage.setItem('has_local_changes', 'true');
                    renderHistory();
                    // Perform blocking Drive sync for delete action
                    try {
                        try { if (window.showLoading) window.showLoading((typeof GN_I18N !== 'undefined') ? GN_I18N.t('syncing_with_drive') : 'Syncing with Google Drive...'); } catch(e){}
                        if (typeof DriveStorage !== 'undefined' && db) {
                            try { await DriveStorage.sync(db); } catch (e) { console.error('Drive sync after deleteDateLogs failed', e); }
                        }
                    } finally { try { if (window.hideLoading) window.hideLoading(); } catch(e){} }
                }
            } else {
                if(confirm(`Delete all entries for ${fmt}?`)) {
                    await db.history.where('date').equals(date).delete();
                    localStorage.setItem('has_local_changes', 'true');
                    renderHistory();
                }
            }
        }

        async function deleteLog(id) {
            const fmt = '';
            if (window.GN_I18N && typeof GN_I18N.t === 'function') {
                const tmpl = GN_I18N.t('history_confirm_delete_exercise') || 'Delete this exercise?';
                if (!confirm(tmpl)) return;
            } else {
                if (!confirm('Delete this exercise?')) return;
            }
            try {
                await db.history.delete(id);
                localStorage.setItem('has_local_changes', 'true');
                renderHistory();
                // Perform blocking Drive sync for delete action
                try {
                    try { if (window.showLoading) window.showLoading((typeof GN_I18N !== 'undefined') ? GN_I18N.t('syncing_with_drive') : 'Syncing with Google Drive...'); } catch(e){}
                    if (typeof DriveStorage !== 'undefined' && db) {
                        try { await DriveStorage.sync(db); } catch (e) { console.error('Drive sync after deleteLog failed', e); }
                    }
                } finally { try { if (window.hideLoading) window.hideLoading(); } catch(e){} }
            } catch (e) {
                console.error('Failed to delete log', e);
            }
        }

        function openEdit(id) {
            if (!id) return;
            location.href = 'historycrud.html?mode=routine&edit=' + encodeURIComponent(id);
        }

        function openEditDate(date) {
            // Backwards-compatible: open by date when needed
            if (!date) return;
            location.href = 'historycrud.html?mode=routine&editDate=' + encodeURIComponent(date);
        }

        function openEditSession(sessionId) {
            if (!sessionId && sessionId !== 0) return;
            location.href = 'historycrud.html?mode=routine&editSession=' + encodeURIComponent(sessionId);
        }

        async function renderHistory() {
            const logs = await db.history.orderBy('date').reverse().toArray();
            // Hide filter controls when there is no history data in the DB
            try {
                const filtersWrap = document.querySelector('.filters-wrap');
                if (filtersWrap) filtersWrap.style.display = (logs && logs.length > 0) ? '' : 'none';
            } catch (e) {}

            // compute available height between bottom of `.top-card` and the top of bottom nav (if present)
            function computeAvailableHeight() {
                try {
                    const topCard = document.querySelector('.top-card');
                    const filtersWrap = document.querySelector('.filters-wrap');
                    const bottomNav = document.getElementById('bottom-nav') || document.getElementById('gn-bottom-nav');
                    // Prefer bottom of filters when visible, otherwise bottom of top-card
                    let topRef = 0;
                    if (filtersWrap && filtersWrap.offsetParent !== null) {
                        topRef = Math.ceil(filtersWrap.getBoundingClientRect().bottom);
                    } else if (topCard) {
                        topRef = Math.ceil(topCard.getBoundingClientRect().bottom);
                    }
                    const bottomHeight = bottomNav ? Math.ceil(bottomNav.getBoundingClientRect().height) : 0;
                    const avail = Math.max(0, window.innerHeight - topRef - bottomHeight);
                    return avail;
                } catch (e) { return 0; }
            }
                if (!logs || logs.length === 0) {
                const container = document.getElementById('history');
                    let msg = '';
                    if (window.GN_I18N && GN_I18N.safeT) {
                        msg = GN_I18N.safeT('history_no_routine');
                    } else {
                        const pageLang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : (navigator.language || 'en');
                        msg = (pageLang && pageLang.startsWith('pt')) ? 'Nenhum treino encontrado' : 'No routine entry found';
                    }
                    const avail = computeAvailableHeight();
                    container.innerHTML = `
                        <div class="empty-state" style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:${avail}px;padding:12px;box-sizing:border-box;">
                            <img src="illustrations/empty-history.svg" alt="" style="width:200px;height:auto;margin:0 auto 10px;display:block;" />
                            <div>${msg}</div>
                        </div>`;
                return;
            }
            // Normalize date strings to YYYY-MM-DD to avoid duplicates caused
            // by mixed formats (e.g., '2026-2-05' vs '2026-02-05' or timestamps).
            function normDateStr(d) {
                if (!d) return d;
                if (typeof d !== 'string') d = String(d);
                // If ISO with time, take first 10 chars
                if (d.indexOf('T') !== -1) return d.split('T')[0];
                // Quick match YYYY-M-D or YYYY-MM-DD
                const m = d.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
                if (m) {
                    const yy = m[1];
                    const mm = String(Number(m[2])).padStart(2, '0');
                    const dd = String(Number(m[3])).padStart(2, '0');
                    return `${yy}-${mm}-${dd}`;
                }
                // Fallback: try Date parse
                const dt = new Date(d);
                if (!isNaN(dt.getTime())) {
                    return dt.toISOString().split('T')[0];
                }
                return d;
            }

            // Group logs by sessionId (fallback to date-based session key when missing)
            const groups = logs.reduce((acc, l) => {
                const sessionKey = (l.sessionId !== undefined && l.sessionId !== null) ? String(l.sessionId) : normDateStr(l.date) || String(l.id || Date.now());
                if (!acc[sessionKey]) acc[sessionKey] = { items: [], sessionDate: null };
                const copy = Object.assign({}, l, { date: normDateStr(l.date) });
                acc[sessionKey].items.push(copy);
                // set sessionDate to the first item's normalized date (used for grouping/filtering/display)
                if (!acc[sessionKey].sessionDate && copy.date) acc[sessionKey].sessionDate = copy.date;
                return acc;
            }, {});

            const container = document.getElementById('history');
            const lang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : 'en';
            const locale = lang === 'pt' ? 'pt' : 'en';
            container.innerHTML = "";

            // Flatten sessions into an array for rendering
            const flatSessions = Object.keys(groups).map(k => ({ sessionId: k, date: groups[k].sessionDate, items: groups[k].items }));
            // sort sessions by date descending (fallback to sessionId when date missing)
            flatSessions.sort((a, b) => {
                if (a.date && b.date) return a.date < b.date ? 1 : -1;
                return (b.sessionId || '') < (a.sessionId || '') ? 1 : -1;
            });

            // Populate filters (month/year) once based on available session dates
            try {
                const monthKeys = Object.values(groups).map(g => g.sessionDate).filter(Boolean).map(d => d.substring(0,7));
                populateFilters(Array.from(new Set(monthKeys)));
            } catch(e) {}

            // read selected filter values (if selects present)
            const monthSel = document.getElementById('filterMonth');
            const yearSel = document.getElementById('filterYear');
            let selectedPrefix = null; // 'YYYY-MM'
            if (monthSel && yearSel) {
                const m = monthSel.value.padStart(2, '0');
                const y = yearSel.value;
                selectedPrefix = `${y}-${m}`;
            }

            // track how many date groups are rendered (used to show filtered empty state)
            let renderedCount = 0;

            for (const entry of flatSessions) {
                if (!entry) continue;
                const sessionId = entry.sessionId;
                const sessionDate = entry.date;
                if (selectedPrefix && !(sessionDate && sessionDate.startsWith(selectedPrefix))) continue;
                const dateDet = document.createElement('details');
                dateDet.className = "history-group";
                const delTitle = GN_I18N && GN_I18N.safeT ? GN_I18N.safeT('history_delete_session') : 'Delete Session';
                const formattedDate = sessionDate ? formatDateDisplay(sessionDate) : '';
                dateDet.innerHTML = `<summary class="date-header"><span>${formattedDate}</span><svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></summary>`;
                // Merge items by exercise so a single exercise isn't rendered multiple times
                const merged = {};
                for (const l of entry.items) {
                    const key = `${l.exerciseId || l.exerciseName || 'unknown'}::${String(!!l.isCustom)}`;
                    if (!merged[key]) merged[key] = Object.assign({}, l);
                    else {
                        // sum sets when possible
                        const a = merged[key];
                        const setsA = Number(a.sets || 0);
                        const setsB = Number(l.sets || 0);
                        a.sets = (setsA + setsB) || a.sets || l.sets;
                        // prefer the most-recent non-empty reps/weight
                        if ((l.reps || l.reps === 0) && !a.reps) a.reps = l.reps;
                        if ((l.weight || l.weight === 0) && !a.weight) a.weight = l.weight;
                        if ((l.imageId || l.imageId === 0) && !a.imageId) a.imageId = l.imageId;
                    }
                }

                const dedupedItems = Object.keys(merged).map(k => merged[k]);
                for (const l of dedupedItems) {
                        // Prefer DB lookup so we can show localized names dynamically
                        const lang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : 'en';
                        let imageId = l.imageId;
                        let isCustom = (typeof l.isCustom === 'boolean') ? l.isCustom : undefined;
                        let exRec = null;

                        // Try to find exercise record in DB (custom first if unknown)
                        if (isCustom === true) exRec = await db.custom_exercises.get(l.exerciseId);
                        else if (isCustom === false) exRec = await db.catalog_exercises.get(l.exerciseId);
                        else {
                            exRec = await db.custom_exercises.get(l.exerciseId);
                            if (!exRec) exRec = await db.catalog_exercises.get(l.exerciseId);
                        }

                        if (exRec) {
                            if (!imageId && exRec.imageId) imageId = exRec.imageId;
                        }

                        const imgTable = isCustom ? db.custom_images : db.catalog_images;
                        let imgSrc = defaultImage;
                        if (imageId) {
                            const imgRec = await imgTable.get(imageId);
                            if (imgRec && imgRec.data) imgSrc = imgRec.data;
                        }

                        const setsText = (lang === 'pt') ? 's√©ries' : (GN_I18N.safeT ? GN_I18N.safeT('history_fmt_sets_short') : 'sets');
                        const kgSuffix = GN_I18N.safeT ? GN_I18N.safeT('history_fmt_kg_suffix') : 'kg';
                        const displayName = (exRec ? ((lang === 'pt' && exRec.namePT) ? exRec.namePT : exRec.name) : (l.exerciseName || (l.exerciseId ? `#${l.exerciseId}` : 'Unknown')));

                        dateDet.innerHTML += `<div class="log-entry"><div class="meta"><div class="name-row"><img src="${imgSrc}" style="width:25px;height:25px;border-radius:4px;object-fit:cover"> ${displayName}</div><div class="data-row">${l.sets || 3} ${setsText} x ${l.weight}${kgSuffix} x ${l.reps}</div></div></div>`;
                }
                    // add session-level edit/delete buttons at the bottom of the session box (localized)
                const pageLang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : (navigator.language || 'en');
                const editText = (window.GN_I18N && GN_I18N.safeT) ? GN_I18N.safeT('history_edit_session') : (pageLang && pageLang.startsWith('pt') ? 'Editar' : 'Edit');
                const delText = (window.GN_I18N && GN_I18N.safeT) ? GN_I18N.safeT('history_delete') : (pageLang && pageLang.startsWith('pt') ? 'Deletar' : 'Delete');
                    dateDet.innerHTML += `<div style="padding:10px 12px;display:flex;justify-content:flex-end;gap:8px"><button class="date-edit-btn" aria-label="${editText}" title="${editText}" onclick="event.stopPropagation(); openEditSession('${sessionId}')">${editText}</button><button class="date-delete-btn" aria-label="${delTitle}" title="${delTitle}" onclick="event.stopPropagation(); deleteSession('${sessionId}')">${delText}</button></div>`;
                // Ensure we don't render the same session twice (protect against previous render anomalies)
                dateDet.setAttribute('data-session-id', sessionId);
                if (!container.querySelector(`.history-group[data-session-id="${sessionId}"]`)) {
                    container.appendChild(dateDet);
                }
                renderedCount++;

                // apply translations to this newly created block if GN_I18N is present
                if (window.GN_I18N && typeof GN_I18N.applyTranslations === 'function') {
                    try { GN_I18N.applyTranslations(dateDet); } catch(e){}
                }
            }

            // If filters are applied but nothing matched, show localized empty-state message
            if (renderedCount === 0) {
                let msg = '';
                if (window.GN_I18N && GN_I18N.safeT) {
                    msg = GN_I18N.safeT('history_no_routine');
                } else {
                    const pageLang = (window.GN_I18N && GN_I18N.getLang) ? GN_I18N.getLang() : (navigator.language || 'en');
                    msg = (pageLang && pageLang.startsWith('pt')) ? 'Nenhum treino encontrado' : 'No routine entry found';
                }
                const avail = computeAvailableHeight();
                container.innerHTML = `
                    <div class="empty-state" style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:${avail}px;padding:12px;box-sizing:border-box;">
                        <img src="illustrations/empty-history.svg" alt="" style="width:200px;height:auto;margin:0 auto 10px;display:block;" />
                        <div>${msg}</div>
                    </div>`;
            }

            // Normalize history DOM to remove accidental nested wrappers
            try { normalizeHistoryList(); } catch (e) { console.warn('normalizeHistoryList failed', e); }
        }

        async function renderWeightHistory() {
            const weights = await db.weights.orderBy('date').reverse().toArray();
            const container = document.getElementById('weight-history');
            // If this page doesn't include a weight-history container, skip rendering.
            if (!container) return;
            container.innerHTML = '';
            if (!weights || weights.length === 0) {
                const msg = (window.GN_I18N && GN_I18N.safeT) ? GN_I18N.safeT('history_no_weight') : 'No weight history';
                container.innerHTML = `<div class="empty-state">${msg}</div>`;
                return;
            }
            const kgSuffix = (window.GN_I18N && GN_I18N.safeT) ? GN_I18N.safeT('history_fmt_kg_suffix') : 'kg';
            for (const w of weights) {
                const formatted = formatDateDisplay(w.date);
                const delTitle = (window.GN_I18N && GN_I18N.safeT) ? GN_I18N.safeT('history_delete_weight') : 'Delete weight';
                container.innerHTML += `<div class="log-entry"><div class="meta"><div class="name-row">${formatted}</div><div class="data-row">${w.weight} ${kgSuffix}</div></div><button class="delete-btn" aria-label="${delTitle}" title="${delTitle}" onclick="event.stopPropagation(); deleteWeight('${w.date}')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button></div>`;
            }
        }

        // Remove nested .history-group/.log-entry wrappers introduced by SPA re-renders
        function normalizeHistoryList() {
            try {
                const container = document.getElementById('history');
                if (!container) return;

                // Unwrap any history-group accidentally nested inside another history-group
                const nestedGroups = Array.from(container.querySelectorAll('.history-group .history-group'));
                nestedGroups.forEach(inner => {
                    const parentGroup = inner.closest('.history-group');
                    if (!parentGroup) return;
                    // move inner's children out into parentGroup before the inner
                    while (inner.firstChild) parentGroup.insertBefore(inner.firstChild, inner);
                    inner.remove();
                });

                // If any .log-entry is nested inside another .log-entry, lift it to be direct child of its nearest .history-group
                const nestedLogEntries = Array.from(container.querySelectorAll('.log-entry .log-entry'));
                nestedLogEntries.forEach(inner => {
                    const parentGroup = inner.closest('.history-group');
                    if (!parentGroup) return;
                    parentGroup.appendChild(inner);
                });

                // Remove empty wrapper nodes (e.g., divs that only held entries)
                Array.from(container.querySelectorAll('.history-group *')).forEach(node => {
                    if (node.nodeType === 1 && !node.classList.contains('history-group') && !node.classList.contains('log-entry') && !node.classList.contains('date-header') && node.childElementCount === 1 && node.textContent.trim() === '') {
                        const only = node.firstElementChild;
                        node.parentNode.replaceChild(only, node);
                    }
                });
            } catch (e) {
                console.warn('normalizeHistoryList error', e);
            }
        }

        async function deleteWeight(date) {
            const fmt = formatDateDisplay(date);
            if (window.GN_I18N && typeof GN_I18N.t === 'function') {
                const tmpl = GN_I18N.t('history_confirm_delete_weight') || GN_I18N.t('history_confirm_delete') || 'Delete this weight entry?';
                if (!confirm(tmpl.replace ? tmpl.replace('{date}', fmt) : tmpl)) return;
            } else {
                if (!confirm(`Delete weight entry for ${fmt}?`)) return;
            }
            try {
                // try delete by primary key first, fallback to where
                try { await db.weights.delete(date); }
                catch (e) { await db.weights.where('date').equals(date).delete(); }
                localStorage.setItem('has_local_changes', 'true');
                renderWeightHistory();
            } catch (e) {
                console.error('Failed to delete weight', e);
            }
        }

        async function deleteSession(sessionId) {
            if (!sessionId && sessionId !== 0) return;
            const fmt = '';
            if (window.GN_I18N && typeof GN_I18N.t === 'function') {
                const tmpl = GN_I18N.t('history_confirm_delete') || 'Delete this session?';
                if (confirm(tmpl.replace ? tmpl.replace('{date}', fmt) : tmpl)) {
                    await db.history.where('sessionId').equals(Number(sessionId)).delete();
                    localStorage.setItem('has_local_changes', 'true');
                    renderHistory();
                    // Perform blocking Drive sync for delete action
                    try {
                        try { if (window.showLoading) window.showLoading((typeof GN_I18N !== 'undefined') ? GN_I18N.t('syncing_with_drive') : 'Syncing with Google Drive...'); } catch(e){}
                        if (typeof DriveStorage !== 'undefined' && db) {
                            try { await DriveStorage.sync(db); } catch (e) { console.error('Drive sync after deleteSession failed', e); }
                        }
                    } finally { try { if (window.hideLoading) window.hideLoading(); } catch(e){} }
                }
            } else {
                if (confirm('Delete this session?')) {
                    await db.history.where('sessionId').equals(Number(sessionId)).delete();
                    localStorage.setItem('has_local_changes', 'true');
                    renderHistory();
                }
            }
        }
        if (window.GN_I18N) {
            try { GN_I18N.applyTranslations(document); } catch(e){}
            try { document.title = GN_I18N.t('title_main') + ' | ' + GN_I18N.t('history_header'); } catch(e){}
        }
        init();
    </script>
    </div>
    </div>
</body>
</html>