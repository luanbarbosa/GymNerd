<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title></title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="favicon.svg">
    <link rel="apple-touch-icon" href="icons/icon-192.svg">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#ffffff">
    <link href="https://fonts.googleapis.com" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,300,0,0" rel="stylesheet">
    <script src="auth.js"></script>
    <script src="drive-storage.js"></script>
    <!-- SortableJS for touch-friendly drag & drop reordering -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="db.js"></script>
    <script src="gn-i18n.js"></script>
    <style>
        :root { --primary: #3b82f6; --secondary: #94a3b8; --primary-grad: linear-gradient(135deg, #60a5fa 0%, #2563eb 100%); --secondary-grad: linear-gradient(135deg, #D1D5DB 0%, #9CA3AF 100%); --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --text-dim: #94a3b8; --success: #10b981; --danger: #ef4444; }
        body { font-family: system-ui, sans-serif; background: var(--bg); color: var(--text); max-width: 500px; margin: 0 auto; padding: 0; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .header { display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; margin-bottom: 20px; }
        /* Top-card (same style used on index.html / settings) */
        .top-card { position: static; background: linear-gradient(180deg, #ffffff 0%, #ffffff 70%, #f3f4f6 100%); color: #0f172a; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; padding: 10px 16px 6px; box-shadow: 0 6px 16px rgba(2,6,23,0.06); padding-top: calc(10px + constant(safe-area-inset-top)); padding-top: calc(10px + env(safe-area-inset-top)); }
        body::before { content: ''; position: fixed; top: 0; left: 0; right: 0; height: constant(safe-area-inset-top); height: env(safe-area-inset-top); background: #ffffff; z-index: 1100; pointer-events: none; }
        .top-card-inner { max-width: 100%; display:flex; flex-direction:column; align-items:center; gap:8px; padding-bottom: 2px; }
        .page-content { padding: 16px; padding-top: 12px; }
        .top-card .topbar { background: transparent; padding: 6px 0; display:flex; align-items:center; justify-content:space-between; width:100%; }
        .top-card .back-btn { color: inherit; }
        /* Ensure back button icons are vertically centered inside top bars */
        .top-card .back-btn, .top-card .back-btn .material-symbols-outlined { display: inline-flex; align-items: center; justify-content: center; line-height: 1; }
        .header-left { display: flex; align-items: center; gap: 15px; }
        .header h2 { font-weight: 800; letter-spacing: -0.5px; background: var(--primary-grad); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 0; }
        .back-btn { text-decoration: none; font-size: 1.5rem; color: var(--bg); }
        .card { background: var(--card); padding: 20px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.05); margin-bottom: 20px; }
        .view-content { padding: 12px 15px 20px 15px; }
        select, button { padding: 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); font-size: 1rem; width: 100%; box-sizing: border-box; background: rgba(255,255,255,0.05); color: white; }
        
        .exercise-list { margin-top: 10px; }
        .exercise-item { 
            background: var(--card); 
            padding: 15px; 
            border-radius: 12px; 
            margin-bottom: 10px; 
            border: 1px solid rgba(255,255,255,0.05); 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        /* Smooth positional transitions when items are reordered */
        .exercise-item {
            transition: transform 180ms cubic-bezier(.2,.8,.2,1);
            will-change: transform;
        }


        .ex-thumb { width: 64px; height: 44px; border-radius: 8px; object-fit: contain; object-position: center; background: #fff; flex-shrink: 0; }
        .player-img { background: #fff; }
        /* Reorder UI */
        .reorder-btn { display: inline-flex; align-items: center; gap:8px; border: none; background: rgba(255,255,255,0.02); color: var(--text-dim); padding: 8px 10px; border-radius: 10px; cursor: pointer; font-weight: 800; transition: background 0.12s, box-shadow 0.12s, color 0.12s, transform 0.08s; }
        .reorder-btn:active { transform: scale(0.98); }
        .reorder-btn svg { stroke: currentColor; transition: stroke 0.12s, transform 0.12s; }

        /* Hide drag handle by default; show when reorder mode is active */
        .drag-handle { display: none; border: none; background: transparent; color: var(--text-dim); font-size: 1.1rem; padding: 6px 8px; border-radius: 8px; }
        .exercise-list.reorder-mode .drag-handle { display: inline-flex; }
        /* Hide delete/remove action while reordering to avoid accidental deletes */
        .exercise-list.reorder-mode .remove-ex-btn { display: none !important; }
        .reorder-btn .label { font-weight: 800; color: var(--text-dim); font-size: 0.95rem; }
        .reorder-btn.active { background: var(--primary); color: #fff; box-shadow: 0 6px 18px rgba(59,130,246,0.12); }
        .reorder-btn.active .label { color: #fff; }
        .reorder-btn:focus { outline: 2px solid rgba(59,130,246,0.12); outline-offset: 2px; }
        .exercise-item.placeholder { border: 2px dashed rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); }
        .dragging { position: fixed; z-index: 1000; pointer-events: none; transform: scale(1.02); box-shadow: 0 10px 30px rgba(0,0,0,0.4); opacity: 0.98; border-radius: 12px; }
        /* Sortable placeholder styling (dashed box matching exercise-item height) */
        .sortable-placeholder { border: 2px dashed rgba(255,255,255,0.12); background: rgba(255,255,255,0.02); border-radius: 12px; }
        .checkbox-wrapper { margin-left: auto; }
        input[type="checkbox"] { width: 24px; height: 24px; cursor: pointer; accent-color: var(--primary); }

        .start-btn { 
            background: var(--primary-grad); 
            color: white; 
            border: none; 
            font-weight: bold; 
            cursor: pointer; 
            margin-top: 20px; 
            display: none;
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.2);
        }

        .player-card { text-align: center; padding-top: 12px; }
        .current-ex-title { font-size: 1.15rem; font-weight: 800; margin: 0 0 10px; color: var(--text); line-height: 1.15; text-align: center; word-break: break-word; }
        /* Reserve space for up to 2 lines; center vertically when only one line */
        .current-ex-title {
            min-height: 2.6em; /* roughly 2 lines based on font-size */
            display: flex;
            align-items: center; /* centers single-line vertically */
            justify-content: center;
            padding: 0 12px;
            text-align: center;
            white-space: normal; /* allow wrapping to second line */
            overflow: hidden;
        }
        /* Fixed image box so all exercise images share the same visible area */
        .player-img { width: 100%; height: clamp(120px, 24vh, 160px); object-fit: contain; object-position: center; border-radius: 16px; margin-bottom: 12px; background: #fff; display: block; }
        /* External spacer: visual spacing will be placed outside the player card so the card's content doesn't get extra inner padding */
        .player-bottom-spacer { height: calc(100px + env(safe-area-inset-bottom)); }
        .ex-nav-bar { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 14px; padding: 8px 10px; background: rgba(255,255,255,0.03); border-radius: 20px; border: 1px solid rgba(255,255,255,0.05); position: relative; overflow: hidden; }
        .ex-title-group { flex: 1; text-align: center; display: flex; flex-direction: column; gap: 2px; min-width: 0; }
        /* exercise title removed per request */
        .current-ex-subtitle { font-size: 0.7rem; color: var(--text-dim); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .header-timer { display: flex; align-items: center; gap: 8px; background: linear-gradient(90deg, rgba(96,165,250,0.12), rgba(37,99,235,0.06)); padding: 6px 12px; border-radius: 10px; border: 1px solid rgba(59,130,246,0.12); cursor: pointer; color: #0f172a; }
        .timer-val { font-size: 1.2rem; font-weight: 800; color: #0f172a; font-variant-numeric: tabular-nums; }
        .progress-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background: rgba(255,255,255,0.02); }
        .progress-bar { height: 100%; background: var(--primary-grad); width: 0%; transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        /* Exercise progress graph (balls and connectors) */
        .exercise-graph { display:flex; gap:8px; align-items:center; justify-content:center; padding-top:8px; padding-left:16px; padding-right:16px; box-sizing:border-box; overflow:hidden; }
        .exercise-node { width:34px; height:34px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:800; color:#0b1220; background:#1e293b; border:2px solid rgba(255,255,255,0.04); cursor:pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.4); flex-shrink:0; }
        .exercise-node.completed { background: var(--success); color: white; border-color: rgba(16,185,129,0.15); }
        .exercise-node.active { box-shadow: 0 6px 18px rgba(59,130,246,0.16); transform: scale(1.06); }
        .exercise-node.skipped { background: rgba(255,255,255,0.04); color: var(--text-dim); border-color: rgba(255,255,255,0.04); }
        .exercise-connector { width:26px; height:4px; background: rgba(255,255,255,0.06); border-radius:2px; flex-shrink:0; }
        .exercise-connector.completed { background: linear-gradient(90deg, #10b981, #34d399); }
        .exercise-count { margin-top:6px; font-size:0.8rem; color:var(--text-dim); text-align:center; }
        /* Full-screen image preview modal */
        .image-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 2200; }
        .image-modal .modal-inner { position: relative; max-width: 92vw; max-height: 92vh; padding: 12px; box-sizing: border-box; background: #fff; border-radius: 12px; }
        .image-modal img { max-width: 100%; max-height: 84vh; border-radius: 8px; display: block; background: #fff; }
        .image-modal .close-btn { position: absolute; top: 8px; right: 8px; width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; background: var(--primary); border: none; color: #fff; border-radius: 50%; cursor: pointer; font-weight: 800; box-shadow: 0 6px 18px rgba(37,99,235,0.22); }
        .image-modal .close-btn:hover { filter: brightness(0.95); }
        .image-modal .close-btn:focus { outline: 3px solid rgba(59,130,246,0.18); }
        .timer-reset { background: none; border: none; color: inherit; cursor: pointer; padding: 0; display: flex; align-items: center; transition: color 0.2s; width: auto !important; }
        .timer-reset:active { color: var(--primary); }

        .resume-card { background: rgba(59, 130, 246, 0.1); border: 1px solid var(--primary); padding: 15px; border-radius: 16px; margin-bottom: 20px; }
        .resume-title { color: var(--primary); font-weight: bold; margin-bottom: 10px; display: block; font-size: 0.9rem; }

        .set-row { display: grid; grid-template-columns: 40px 1fr 1fr; gap: 10px; align-items: center; padding: 12px; border-radius: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.03); border: 1px solid transparent; transition: all 0.2s; }
        .set-row.completed { background: rgba(16, 185, 129, 0.1); border-color: var(--success); }
        .set-row.skipped { background: rgba(255,255,255,0.05); border-color: #475569; opacity: 0.5; }
        .set-row.active { background: rgba(59, 130, 246, 0.15); border-color: var(--primary); transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.2); animation: pulse 2s infinite; }
        @keyframes pulse { 0% { border-color: var(--primary); } 50% { border-color: #60a5fa; } 100% { border-color: var(--primary); } }
        .set-row input { width: 100%; padding: 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; text-align: center; font-size: 0.88rem; box-sizing: border-box; background: #000; color: white; }
        .set-label { font-weight: bold; color: var(--text-dim); font-size: 0.62rem; text-transform:uppercase; }
        .input-field-label { font-size: 0.56rem; color: var(--text-dim); font-weight:700; text-transform:uppercase; display:block; }

        /* Header row for reps/kg labels that aligns with .set-row columns */
        .set-row.header { background: transparent; border: none; margin-bottom: 6px; padding-top: 6px; padding-bottom: 6px; }
        .set-row.header .input-field-label { opacity: 0.9; display:block; }

        .player-controls-icons { display: flex; justify-content: center; gap: 20px; margin-top: 25px; }
        /* Bottom action bar (fixed) */
        .BottomActionBar{position:fixed;left:0;right:0;bottom:0;height:84px;background:linear-gradient(180deg, rgba(0,0,0,0.4), rgba(0,0,0,0.6));backdrop-filter:blur(6px);display:flex;align-items:center;padding:12px 16px;gap:12px}
        .BottomActionBar .ba-left{display:none}
        .BottomActionBar .ba-center{display:flex;gap:20px;flex:1;align-items:center;justify-content:center;position:relative;left:auto;transform:none}
        .BottomActionBar .confirm{width:56px;height:56px;border-radius:14px;background:linear-gradient(90deg,var(--primary),#2563eb);border:none;color:white;font-size:22px;display:flex;align-items:center;justify-content:center}
        /* Play button inside bottom bar: center and wrap to its title */
        .BottomActionBar #activateExBtn{display:none;box-sizing:border-box;display:inline-flex;height:56px;padding:0 28px;border-radius:14px;font-weight:800;background:var(--primary-grad);color:#fff;flex:0 0 auto;width:auto;min-width:140px;max-width:90%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center;align-items:center;justify-content:center;font-size:16px;align-self:center;line-height:1;margin:0}
        .icon-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            cursor: pointer;
            transition: all 0.16s cubic-bezier(0.4, 0, 0.2, 1);
            color: white;
            box-shadow: 0 6px 16px rgba(0,0,0,0.28);
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            background-clip: padding-box;
        }
        .icon-btn:active { transform: scale(0.92); box-shadow: 0 3px 8px rgba(0,0,0,0.3); }
        .icon-btn.prev { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); color: var(--text-dim); }
        .icon-btn.skip { background: rgba(239, 68, 68, 0.12); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.18); }
        .icon-btn.next { background: var(--primary-grad); }

        /* Ensure SVGs inside buttons are centered and sized consistently */
        .icon-btn svg { width: 20px; height: 20px; display: block; }

        .nav-ex-btn {
            background: none;
            border: none;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            flex-shrink: 0;
            padding: 0;
        }
        .nav-ex-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .nav-ex-btn:active:not(:disabled) { transform: scale(0.8); color: var(--text); }

        .finish-btn { background: var(--success); color: white; border: none; font-weight: bold; cursor: pointer; margin-top: 20px; }
        .remove-ex-btn { background: transparent; border: none; color: var(--danger); display: inline-flex; align-items: center; padding: 6px; border-radius: 8px; cursor: pointer; }
        .remove-ex-btn svg { display: block; }
        
        .hidden { display: none !important; }
        .save-warning-box {
            background: linear-gradient(180deg, rgba(250,204,21,0.12), rgba(250,204,21,0.06));
            border: 1px solid rgba(250,204,21,0.18);
            padding: 12px;
            border-radius: 12px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .save-warning-box .warning-note { color: var(--text); opacity: 0.95; font-size: 0.92rem; text-align: center; }
          /* Finished view: full-bleed illustration while keeping content constrained
              Ensure the finished view fits the viewport without scrolling. */
        /* Let the finished view fill the viewport; image should grow to available space above content */
        /* Fix finished view to the viewport so it always fills available space */
        #finishedView { display: flex; flex-direction: column; position: fixed; inset: 0; padding: 0; margin: 0; box-sizing: border-box; overflow: hidden; z-index: 1200; }
          /* Fullscreen illustration: position absolutely to fill viewport but stop above content
              The bottom offset is controlled by the CSS variable --finished-content-height set by JS. */
          .finished-illustration { position: absolute; top: 0; left: 0; right: 0; bottom: var(--finished-content-height, 96px); width: 100%; height: auto; margin: 0; display:block; box-sizing: border-box; }
        /* Image covers the full-bleed area */
        .finished-illustration img, .finished-illustration-img { width: 100%; height: 100%; object-fit: cover; object-position: center center; display:block; opacity: 0.7; }
        /* Content constrained and pinned to bottom above safe area
           Add extra bottom spacing so the finish button isn't flush to the screen edge. */
        .finished-content { position: absolute; left: 50%; transform: translateX(-50%); bottom: calc(env(safe-area-inset-bottom, 12px) + 12px); width: min(500px, calc(100% - 32px)); padding: 8px 12px; box-sizing: border-box; text-align:center; z-index: 3; }

        /* More impactful finished title */
        .finished-content h2 {
            font-size: 1.9rem;
            line-height: 1.02;
            font-weight: 900;
            margin: 0 0 8px;
            background: var(--primary-grad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.4px;
            text-align: center;
        }

        .finished-content p { margin: 0 0 12px; color: var(--text-dim); font-weight: 700; }

        /* Extra spacing below the finish button */
        .finished-content .finish-btn { margin-bottom: 8px; }
        /* Exercise progress graph styles */
        .exercise-graph { padding:8px 18px; box-sizing:border-box; display:flex; align-items:center; justify-content:center; overflow:visible; }
        /* Player card title overlay (title removed) */
        .player-card { position: relative; }
        .exercise-node { display:inline-flex; align-items:center; justify-content:center; border-radius:999px; background:rgba(255,255,255,0.06); color:var(--text); width:34px; height:34px; flex:0 0 auto; border:2px solid rgba(255,255,255,0.06); font-weight:700; }
        .exercise-node-label { display:block; width:100%; text-align:center; line-height:1; font-size:14px; }
        /* Slight optical nudge for symbol-based nodes to match numeric centering */
        .exercise-node.completed .exercise-node-label,
        .exercise-node.skipped .exercise-node-label { transform: translateX(0.6px); }
        .exercise-node.completed { background:linear-gradient(90deg,var(--primary),#2563eb); color:white; border-color:transparent; }
        .exercise-node.skipped { background: rgba(239,68,68,0.14); color:#ef4444; border-color: rgba(239,68,68,0.2); }
        .exercise-node.active { 
            /* stronger solid white ring for the viewed exercise */
            box-shadow: 0 6px 16px rgba(0,0,0,0.35), 0 0 0 3px rgba(255,255,255,0.98);
            transform: translateY(-2px);
            border-width: 3px;
            border-color: #ffffff;
            z-index: 2;
        }
        .exercise-connector { background:rgba(255,255,255,0.06); height:4px; border-radius:2px; display:inline-block; }
        .exercise-count { margin-top:6px; font-size:0.8rem; color:var(--text-dim); text-align:center; }
    </style>
</head>
<body>
    <div id="setupView">
        <div class="top-card">
            <div class="top-card-inner">
                <div class="topbar">
                    <div style="display:flex;align-items:center;width:100%;gap:12px;">
                        <a href="home.html" class="back-btn" aria-label="Back"><span class="material-symbols-outlined" aria-hidden="true" style="font-variation-settings: 'wght' 300;">arrow_back</span></a>
                        <div style="flex:1;min-width:0;">
                            <h2 data-i18n="page_start_routine"></h2>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="view-content">
            <div id="resumeCard" class="resume-card" style="display: none;">
                <span class="resume-title" data-i18n="resume_unfinished"></span>
                <div style="display:flex; gap:10px">
                    <button id="resumeContinueBtn" onclick="resumeSession()" style="background:var(--primary); color:white; border:none; padding:10px; border-radius:8px; font-weight:bold; cursor:pointer; flex:2" data-i18n="resume_continue"></button>
                    <button id="resumeDiscardBtn" onclick="discardSession()" style="background:white; color:#ef4444; border:1px solid #fee2e2; padding:10px; border-radius:8px; font-weight:bold; cursor:pointer; flex:1" data-i18n="resume_discard"></button>
                </div>
            </div>

            <div class="card">
                <label style="font-size:0.8rem; font-weight:bold; display:block; margin-bottom:5px" data-i18n="label_select_routine"></label>
                <select id="workoutSelect" onchange="loadExercises()">
                    <option value="" data-i18n="choose_routine_placeholder"></option>
                </select>

                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button id="toggleSortBtn" type="button" class="reorder-btn" style="display:none" onclick="toggleSortMode()" title="Ordenar">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="7" x2="20" y2="7"></line><line x1="4" y1="12" x2="14" y2="12"></line><line x1="4" y1="17" x2="10" y2="17"></line></svg>
                        <span class="label">Ordenar</span>
                    </button>
                </div>

                <div id="exerciseContainer" class="exercise-list"></div>
                <button id="startBtn" class="start-btn" onclick="startSession()" data-i18n="start_session"></button>
            </div>
        </div>
    </div>

    <div id="playerView" style="display: none;">
        <div class="top-card">
            <div class="top-card-inner">
                <div class="topbar">
                    <div style="display:flex;align-items:center;gap:12px;min-width:0;">
                        <a href="livesession.html" class="back-btn" aria-label="Back"><span class="material-symbols-outlined" aria-hidden="true" style="font-variation-settings: 'wght' 300;">arrow_back</span></a>
                        <div style="flex:1;min-width:0;">
                            <h2 id="playerWorkoutTitle"></h2>
                        </div>
                    </div>
                    <div class="header-timer" onclick="startTimer()">
                        <div id="setTimer" class="timer-val">00:00</div>
                        <button class="timer-reset">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="view-content">
            <div class="ex-nav-bar">
                <button id="prevExBtn" class="nav-ex-btn" onclick="navExercise(-1)">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
                <div class="ex-title-group">
                    <div id="exerciseProgressGraph" class="exercise-graph" aria-hidden="true"></div>
                </div>
                <button id="nextExBtn" class="nav-ex-btn" onclick="navExercise(1)">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </button>
                <div class="progress-container"><div id="progressBar" class="progress-bar"></div></div>
            </div>
            <!-- graph moved inside title box above -->
            <div class="card player-card">
                <h3 id="currentExName" class="current-ex-title" aria-live="polite"></h3>
                <img id="playerImg" src="" class="player-img" onclick="showImagePreview(this.src)" style="cursor:pointer" aria-label="Preview image">
                <div id="setsContainer"></div>
                <!-- Player controls moved to fixed bottom bar -->
                <button id="finishBtn" class="finish-btn" style="display:none; width:100%; padding:12px; border-radius:8px" onclick="finishSession()" data-i18n="finish_routine"></button>
            </div>
            <div id="playerBottomSpacer" class="player-bottom-spacer" aria-hidden="true"></div>
        </div>
    </div>

    
        <!-- Fixed bottom action bar for player controls -->
        <aside id="bottomBar" class="BottomActionBar" role="region" aria-label="Player actions" style="display:none;">
            <div class="ba-center">
                <button id="bb-prev" class="icon-btn prev" title="Previous">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </button>
                <button id="bb-skip" class="icon-btn skip" title="Skip">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
                <button id="activateExBtn" class="start-btn" style="display:none;" onclick="activateExercise()" data-i18n="play_exercise">Play</button>
                <button id="bb-next" class="icon-btn next" title="Complete">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </button>
            </div>
        </aside>

        <!-- Finished view shown when all exercises are completed -->
        <div id="finishedView" style="display:none;">
            <div class="finished-illustration" aria-hidden="true">
                <img src="illustration-livesession-end.svg" alt="Success illustration" class="finished-illustration-img">
            </div>
            <div class="finished-content">
                <h2 data-i18n="finished_title" style="margin-top:0;"></h2>
                <p data-i18n="finished_subtitle" style="color:var(--text-dim); margin:10px 0 20px;"></p>
                <div style="display:flex; gap:10px; justify-content:center; align-items:center; flex-direction:column;">
                    <div id="saveRoutineOpt" class="save-warning-box" style="display:none; margin-bottom:12px;">
                        <div class="warning-note" data-i18n="save_routine_warning"></div>
                        <small style="color:var(--text-dim);" data-i18n="save_routine_note"></small>
                        <label style="display:flex; gap:10px; align-items:center; color:var(--text); margin-top:6px;">
                            <input id="saveRoutineCheckbox" type="checkbox" />
                            <span data-i18n="save_changes_to_routine"></span>
                        </label>
                    </div>
                    <button id="finishRoutineBtn" class="finish-btn" style="min-width:140px; width:100%;" onclick="finishSession()" data-i18n="finish_routine"></button>
                </div>
            </div>
        </div>

        <script>

        let sessionSets = [];
        let currentIdx = 0;
        let viewingIdx = 0;
        let currentWorkoutId = null;
        let timerInterval = null;
        let timerStartMs = null; // timestamp (ms) when current timer started
        let routineModified = false;
        let _finishingSession = false;

        function formatTime(s) {
            const minutes = Math.floor(s / 60).toString().padStart(2, '0');
            const seconds = (s % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        /* Use GN_I18N.getLang() from gn-i18n.js for language detection. */

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerStartMs = null;
        }

        function updateTimerDisplay() {
            try {
                const timerEl = document.getElementById('setTimer');
                if (!timerEl) return;
                const elapsedSec = timerStartMs ? Math.floor((Date.now() - timerStartMs) / 1000) : 0;
                timerEl.innerText = formatTime(elapsedSec);
            } catch (e) { /* ignore */ }
        }

        function startTimer() {
            stopTimer();
            // Use wall-clock time so elapsed keeps increasing even when page is hidden/throttled.
            timerStartMs = Date.now();
            updateTimerDisplay();
            // Update once per second when possible; when hidden the next tick will reflect full elapsed time.
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        // Ensure display refreshes immediately when page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) updateTimerDisplay();
        });

        // Ensure the fullscreen illustration doesn't extend under the constrained content
        function updateFinishedIllustration() {
            const finishedView = document.getElementById('finishedView');
            if (!finishedView) return;
            const ill = finishedView.querySelector('.finished-illustration');
            const content = finishedView.querySelector('.finished-content');
            if (!ill || !content) return;

            // measure content height including margins
            const contentRect = content.getBoundingClientRect();
            const bottomGap = 12; // spacing between image and content
            // safe-area-inset-bottom can't be read directly; use env() fallback of 0
            const reserved = Math.ceil(contentRect.height + bottomGap);

            // Set CSS variable on finishedView so CSS positions the illustration above content
            finishedView.style.setProperty('--finished-content-height', reserved + 'px');
            // ensure content is above the illustration
            ill.style.zIndex = 1;
            content.style.zIndex = 3;
        }

        window.addEventListener('resize', () => requestAnimationFrame(updateFinishedIllustration));
        window.addEventListener('orientationchange', () => requestAnimationFrame(updateFinishedIllustration));

        async function init() {
            await ensureDbOpen();
            // Default images will use `defaultImage` defined in `db.js` when specific images are missing.
            const workouts = await db.routines.toArray();
            const select = document.getElementById('workoutSelect');
            const lang = GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            workouts.forEach(w => {
                const opt = document.createElement('option');
                opt.value = w.id;
                opt.textContent = (lang.startsWith('pt') && w.namePT) ? w.namePT : w.name;
                select.appendChild(opt);
            });
            // apply static translations from GN_I18N
            try { GN_I18N.applyTranslations(document); } catch(e){}
            // set document title
            try { document.title = GN_I18N.t('title_main') + ' | ' + GN_I18N.t('page_start_routine'); } catch(e){}
            // set control/tooltips
            try {
                document.querySelector('.header-timer').title = GN_I18N.t('reset_timer');
                const prevEx = document.getElementById('prevExBtn'); if (prevEx) prevEx.title = GN_I18N.t('previous_exercise');
                const nextEx = document.getElementById('nextExBtn'); if (nextEx) nextEx.title = GN_I18N.t('next_exercise');
                const prevSetBtn = document.querySelector('.icon-btn.prev'); if (prevSetBtn) prevSetBtn.title = GN_I18N.t('previous_set');
                const skipSetBtn = document.querySelector('.icon-btn.skip'); if (skipSetBtn) skipSetBtn.title = GN_I18N.t('skip_set');
                const nextSetBtn = document.getElementById('nextBtn'); if (nextSetBtn) nextSetBtn.title = GN_I18N.t('complete_set');
            } catch(e){}
            checkActiveSession();
        }

        function checkActiveSession() {
            const saved = localStorage.getItem('gymNerd_activeSession');
            if (saved) {
                document.getElementById('resumeCard').style.display = 'block';
            }
        }

        function saveSessionState() {
            const state = { sessionSets, currentIdx, viewingIdx, currentWorkoutId };
            localStorage.setItem('gymNerd_activeSession', JSON.stringify(state));
        }

        function clearSessionState() {
            localStorage.removeItem('gymNerd_activeSession');
        }

        async function resumeSession() {
            const saved = localStorage.getItem('gymNerd_activeSession');
            if (!saved) return;
            const state = JSON.parse(saved);
            sessionSets = state.sessionSets;
            currentIdx = state.currentIdx;
            viewingIdx = state.viewingIdx || state.currentIdx;
            currentWorkoutId = state.currentWorkoutId;

            const workout = await db.routines.get(currentWorkoutId);
            if (workout) {
                const lang = GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
                document.getElementById('playerWorkoutTitle').innerText = (lang.startsWith('pt') && workout.namePT) ? workout.namePT : workout.name;
            }

            document.getElementById('setupView').style.display = 'none';
            document.getElementById('playerView').style.display = 'block';
            const bb = document.getElementById('bottomBar'); if (bb) bb.style.display = 'flex';
            // reset routine modified flag on resume; checkbox hidden until user changes values
            routineModified = false;
            const saveOpt = document.getElementById('saveRoutineOpt'); if (saveOpt) saveOpt.style.display = 'none';
                // Try to keep screen awake if user enabled the setting: prefer Wake Lock API, otherwise start silent audio (iOS fallback)
                (async () => {
                    try {
                        const keep = (typeof getCookie === 'function' && getCookie('gn_keep_awake') === '1');
                        if (keep) {
                            if ('wakeLock' in navigator) {
                                await requestWakeLock();
                            } else {
                                // start silent audio on user gesture (startSession is a user gesture)
                                await startSilentAudio();
                            }
                        }
                    } catch (err) {
                        console.warn('Could not acquire wake resources or start silent audio:', err);
                    }
                    renderSet();
                })();
        }

        async function discardSession() {
            if (confirm(GN_I18N.t('discard_confirm'))) {
                clearSessionState();
                // Stop any wake resources (wake lock or silent audio) before leaving
                try { await releaseWakeResources(); } catch (e) { console.warn('Error releasing wake resources', e); }
                document.getElementById('resumeCard').style.display = 'none';
            }
        }

        async function loadExercises() {
            const workoutId = parseInt(document.getElementById('workoutSelect').value);
            const container = document.getElementById('exerciseContainer');
            const startBtn = document.getElementById('startBtn');
            
            if (!workoutId) {
                container.innerHTML = "";
                startBtn.style.display = "none";
                const toggleBtn = document.getElementById('toggleSortBtn');
                if (toggleBtn) {
                    toggleBtn.style.display = 'none';
                }
                container.classList.remove('reorder-mode');
                return;
            }

            const workout = await db.routines.get(workoutId);
            const [catalogEx, customEx] = await Promise.all([
                db.catalog_exercises.toArray(),
                db.custom_exercises.toArray()
            ]);
            const allExercises = [
                ...catalogEx.map(ex => ({ ...ex, isCustom: false })),
                ...customEx.map(ex => ({ ...ex, isCustom: true }))
            ];
            const lang = GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            
            container.innerHTML = "";
            for (const item of workout.exerciseIds) {
                const id = typeof item === 'object' ? item.id : item;
                const isCustom = typeof item === 'object' ? !!item.isCustom : false;
                const ex = allExercises.find(e => e.id === id && !!e.isCustom === isCustom);
                if (!ex) continue;

                const imgTable = isCustom ? db.custom_images : db.catalog_images;
                let imgSrc = defaultImage;
                if (ex.imageId) {
                    const imgRecord = await imgTable.get(ex.imageId);
                    if (imgRecord && imgRecord.data) imgSrc = imgRecord.data;
                }

                const details = typeof item === 'object' 
                    ? `<br><small>${Array.isArray(item.sets) ? item.sets.length : item.sets} ${GN_I18N.t('history_sets')}${!Array.isArray(item.sets) ? ` x ${item.reps} ${GN_I18N.t('history_reps')} @ ${item.weight}${GN_I18N.t('history_fmt_kg_suffix')}` : ''}</small>` 
                    : ''; 

                const displayName = (lang === 'pt' && ex.namePT) ? ex.namePT : ex.name;
                const div = document.createElement('div');
                div.className = 'exercise-item';
                div.dataset.id = id;
                div.dataset.iscustom = isCustom;
                div.innerHTML = `
                    <img src="${imgSrc}" class="ex-thumb" onerror="this.style.display='none'">
                    <div style="flex:1; min-width:0;"><strong>${displayName}</strong>${details}</div>
                        <div style="display:flex; gap:8px; align-items:center;">
                        <button type="button" class="remove-ex-btn" title="Remover" onclick="this.closest('.exercise-item').remove()">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                        <button class="drag-handle" title="${GN_I18N.t ? GN_I18N.t('drag_to_reorder') : 'Drag to reorder'}">â˜°</button>
                    </div>
                `;
                container.appendChild(div);
            }
            startBtn.style.display = "block";
            const toggleBtn = document.getElementById('toggleSortBtn');
            if (toggleBtn) {
                toggleBtn.style.display = 'inline-flex';
                // ensure reorder mode is reset when loading a new routine
                document.getElementById('exerciseContainer').classList.remove('reorder-mode');
                toggleBtn.classList.remove('active');
            }
            // translate any newly inserted elements (option/labels inside this container)
            try { GN_I18N.applyTranslations(document.getElementById('workoutSelect').parentNode); } catch(e){}
            attachDragHandlers();
        }

        // --- Drag & drop reordering (mobile-optimized custom) ---
        let _dragState = null;
        let _dragListeners = [];

        function attachDragHandlers() {
            const container = document.getElementById('exerciseContainer');
            if (!container) return;
            container.querySelectorAll('.drag-handle').forEach(h => {
                if (h._dragAttached) return;
                h.addEventListener('touchstart', _onHandleTouchStart, { passive: false });
                h.addEventListener('pointerdown', _onHandlePointerDown);
                h._dragAttached = true;
            });
        }

        function detachDragHandlers() {
            const container = document.getElementById('exerciseContainer');
            if (!container) return;
            container.querySelectorAll('.drag-handle').forEach(h => {
                if (!h._dragAttached) return;
                try { h.removeEventListener('touchstart', _onHandleTouchStart); } catch (e) {}
                try { h.removeEventListener('pointerdown', _onHandlePointerDown); } catch (e) {}
                h._dragAttached = false;
            });
        }

        function _onHandleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            _onHandlePointerDown(touch);
        }

        function _onHandlePointerDown(e) {
            const handle = e.target.closest('.drag-handle');
            if (!handle) return;
            const item = handle.closest('.exercise-item');
            if (!item) return;
            _startDrag(e, item);
        }

        function _startDrag(e, item) {
            // Prevent multiple drags
            if (_dragState) return;
            const container = document.getElementById('exerciseContainer');
            const rect = item.getBoundingClientRect();
            const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;

            const placeholder = document.createElement('div');
            placeholder.className = 'exercise-item placeholder';
            placeholder.style.height = rect.height + 'px';
            placeholder.style.width = rect.width + 'px';
            placeholder.style.boxSizing = 'border-box';

            const ghost = item.cloneNode(true);
            // remove any interactive/remove buttons from the ghost so they don't appear while dragging
            const ghostRemove = ghost.querySelectorAll('.remove-ex-btn');
            ghostRemove.forEach(el => el.remove());
            ghost.classList.add('dragging');
            ghost.style.width = rect.width + 'px';
            ghost.style.left = rect.left + 'px';
            ghost.style.top = rect.top + 'px';
            ghost.style.position = 'fixed';
            ghost.style.margin = '0';
            ghost.style.transform = 'translate3d(0,0,0)';
            ghost.style.willChange = 'transform';
            document.body.appendChild(ghost);

            // hide original and insert placeholder
            item.style.display = 'none';
            const originalParent = item.parentNode;
            const originalNextSibling = item.nextSibling;
            item.parentNode.insertBefore(placeholder, originalNextSibling);

            // prevent page scroll during drag
            const preventScroll = (ev) => { ev.preventDefault(); };
            document.addEventListener('touchmove', preventScroll, { passive: false });

            _dragState = {
                draggingEl: item,
                container,
                placeholder,
                ghost,
                offsetY: clientY - rect.top,
                offsetX: clientX - rect.left,
                raf: null,
                lastY: clientY,
                lastX: clientX,
                preventScroll,
                originalParent,
                originalNextSibling
            };

            function moveHandler(ev) {
                const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
                const x = ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || 0;
                _dragState.lastY = y; _dragState.lastX = x;
                if (!_dragState.raf) {
                    _dragState.raf = requestAnimationFrame(() => {
                        _dragState.ghost.style.transform = `translate3d(${_dragState.lastX - _dragState.offsetX - rect.left}px, ${_dragState.lastY - _dragState.offsetY - rect.top}px, 0)`;
                        // reposition placeholder using elementFromPoint with a movement threshold + FLIP animation
                        try {
                            const elUnder = document.elementFromPoint(_dragState.lastX, _dragState.lastY);
                            if (!elUnder) return;
                            const candidate = elUnder.closest('.exercise-item');
                            const container = _dragState.container;

                            // capture before positions
                            const beforeChildren = Array.from(container.querySelectorAll('.exercise-item'));
                            const beforeRects = beforeChildren.map(c => c.getBoundingClientRect());

                            let moved = false;

                            if (!candidate) {
                                // append at end if not already there
                                if (container.lastElementChild !== _dragState.placeholder) {
                                    container.appendChild(_dragState.placeholder);
                                    moved = true;
                                    _dragState.lastCandidate = null;
                                    _dragState.lastSide = 'end';
                                }
                            } else if (candidate === _dragState.placeholder || candidate === _dragState.draggingEl) {
                                // do nothing
                            } else {
                                const r = candidate.getBoundingClientRect();
                                const topThresh = r.top + r.height * 0.25;
                                const bottomThresh = r.top + r.height * 0.75;
                                let side = 'middle';
                                if (_dragState.lastY < topThresh) side = 'before';
                                else if (_dragState.lastY > bottomThresh) side = 'after';

                                // only move if we are comfortably past threshold and candidate/side changed
                                if (side !== 'middle') {
                                    const sameCandidate = (_dragState.lastCandidate === candidate);
                                    const sameSide = (_dragState.lastSide === side);
                                    if (!sameCandidate || !sameSide) {
                                        if (side === 'before') candidate.parentNode.insertBefore(_dragState.placeholder, candidate);
                                        else candidate.parentNode.insertBefore(_dragState.placeholder, candidate.nextSibling);
                                        moved = true;
                                        _dragState.lastCandidate = candidate;
                                        _dragState.lastSide = side;
                                    }
                                }
                            }

                            if (moved) {
                                // capture after positions and animate differences (FLIP)
                                const afterChildren = Array.from(container.querySelectorAll('.exercise-item'));
                                const afterRects = afterChildren.map(c => c.getBoundingClientRect());

                                beforeChildren.forEach((el, i) => {
                                    if (el === _dragState.draggingEl || el === _dragState.placeholder) return;
                                    const before = beforeRects[i];
                                    const newIndex = afterChildren.indexOf(el);
                                    if (newIndex === -1) return;
                                    const after = afterRects[newIndex];
                                    const dx = before.left - after.left;
                                    const dy = before.top - after.top;
                                    if (dx || dy) {
                                        el.style.transition = 'none';
                                        el.style.transform = `translate3d(${dx}px, ${dy}px, 0)`;
                                        requestAnimationFrame(() => {
                                            el.style.transition = 'transform 180ms cubic-bezier(.2,.8,.2,1)';
                                            el.style.transform = '';
                                            const cleanup = () => { el.style.transition = ''; el.removeEventListener('transitionend', cleanup); };
                                            el.addEventListener('transitionend', cleanup);
                                        });
                                    }
                                });
                            }
                        } catch (err) { console.warn('drag reposition error', err); }
                        // if pointer moves outside visible viewport by a margin, cancel and revert
                        const margin = 40;
                        if (_dragState.lastX < -margin || _dragState.lastX > (window.innerWidth + margin) || _dragState.lastY < -margin || _dragState.lastY > (window.innerHeight + margin)) {
                            try { _cancelDrag(); } catch (err) { console.warn('cancelDrag failed', err); }
                            _dragState.raf = null;
                            return;
                        }
                        _dragState.raf = null;
                    });
                }
            }

            function upHandler() { _endDrag(); }

            // attach listeners
            window.addEventListener('touchmove', moveHandler, { passive: false });
            window.addEventListener('pointermove', moveHandler);
            window.addEventListener('touchend', upHandler);
            window.addEventListener('pointerup', upHandler);
            window.addEventListener('touchcancel', upHandler);

            _dragListeners.push({ moveHandler, upHandler });
        }

        function _endDrag() {
            if (!_dragState) return;
            const { draggingEl, placeholder, ghost, preventScroll } = _dragState;
            // place element where placeholder is
            try {
                placeholder.parentNode.insertBefore(draggingEl, placeholder);
            } catch (e) { console.warn('insert before failed', e); }
            draggingEl.style.display = '';
            if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
            if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);

            // remove scroll prevention
            try { document.removeEventListener('touchmove', preventScroll, { passive: false }); } catch (e) { document.removeEventListener('touchmove', preventScroll); }

            // remove listeners
            for (const L of _dragListeners) {
                try { window.removeEventListener('touchmove', L.moveHandler); } catch (e) {}
                try { window.removeEventListener('pointermove', L.moveHandler); } catch (e) {}
                try { window.removeEventListener('touchend', L.upHandler); } catch (e) {}
                try { window.removeEventListener('pointerup', L.upHandler); } catch (e) {}
                try { window.removeEventListener('touchcancel', L.upHandler); } catch (e) {}
            }
            _dragListeners = [];

            _dragState = null;
        }

        function _cancelDrag() {
            if (!_dragState) return;
            const { draggingEl, placeholder, ghost, preventScroll, originalParent, originalNextSibling } = _dragState;
            // revert item to original position
            try {
                if (originalParent) {
                    if (originalNextSibling && originalNextSibling.parentNode === originalParent) originalParent.insertBefore(draggingEl, originalNextSibling);
                    else originalParent.appendChild(draggingEl);
                }
            } catch (e) { console.warn('revert insert failed', e); }
            draggingEl.style.display = '';
            if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
            if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);

            try { document.removeEventListener('touchmove', preventScroll, { passive: false }); } catch (e) { document.removeEventListener('touchmove', preventScroll); }

            for (const L of _dragListeners) {
                try { window.removeEventListener('touchmove', L.moveHandler); } catch (e) {}
                try { window.removeEventListener('pointermove', L.moveHandler); } catch (e) {}
                try { window.removeEventListener('touchend', L.upHandler); } catch (e) {}
                try { window.removeEventListener('pointerup', L.upHandler); } catch (e) {}
                try { window.removeEventListener('touchcancel', L.upHandler); } catch (e) {}
            }
            _dragListeners = [];
            _dragState = null;
        }

                // Toggle sort mode for the exercise list. When turning off, persist order to DB.
                async function persistExerciseOrder(workoutId) {
                    const container = document.getElementById('exerciseContainer');
                    if (!container) return;
                    const children = [...container.querySelectorAll('.exercise-item')];
                    const workout = await db.routines.get(workoutId);
                    if (!workout) return;
                    const original = workout.exerciseIds || [];

                    const used = new Array(original.length).fill(false);
                    const newOrder = children.map((el, idx) => {
                        const id = el.dataset.id ? parseInt(el.dataset.id) : null;
                        const isCustom = el.dataset.iscustom === 'true';
                        let matchIndex = -1;
                        for (let i = 0; i < original.length; i++) {
                            const item = original[i];
                            const itemId = typeof item === 'object' ? item.id : item;
                            const itemIsCustom = typeof item === 'object' ? !!item.isCustom : false;
                            if (!used[i] && itemId === id && itemIsCustom === isCustom) { matchIndex = i; break; }
                        }
                        let newItem;
                        if (matchIndex >= 0) {
                            used[matchIndex] = true;
                            const origItem = original[matchIndex];
                            if (typeof origItem === 'object') {
                                newItem = { ...origItem };
                            } else {
                                newItem = origItem;
                            }
                        } else {
                            newItem = { id, isCustom };
                        }
                        return newItem;
                    });
                    await db.routines.update(workoutId, { exerciseIds: newOrder });
                    localStorage.setItem('has_local_changes', 'true');
                }

                function toggleSortMode() {
                    const container = document.getElementById('exerciseContainer');
                    if (!container) return;
                    const btn = document.getElementById('toggleSortBtn');
                    const isActive = container.classList.toggle('reorder-mode');
                    if (btn) btn.classList.toggle('active', isActive);

                    if (isActive) {
                        // enable custom drag handlers
                        attachDragHandlers();
                    } else {
                        // disable handlers and persist order
                        detachDragHandlers();
                        // ensure any active drag is ended
                        try { _endDrag(); } catch (e) {}
                        const workoutId = parseInt(document.getElementById('workoutSelect').value);
                        if (workoutId) persistExerciseOrder(workoutId).catch(err => console.warn('persistExerciseOrder failed', err));
                    }
                }

        async function startSession() {
            const workoutId = parseInt(document.getElementById('workoutSelect').value);
            currentWorkoutId = workoutId;
            const workout = await db.routines.get(workoutId);
            const [catalogEx, customEx] = await Promise.all([
                db.catalog_exercises.toArray(),
                db.custom_exercises.toArray()
            ]);
            const allExercises = [
                ...catalogEx.map(ex => ({ ...ex, isCustom: false })),
                ...customEx.map(ex => ({ ...ex, isCustom: true }))
            ];
            const container = document.getElementById('exerciseContainer');
            const visibleItems = Array.from(container.querySelectorAll('.exercise-item'));
            if (visibleItems.length === 0) return alert(GN_I18N.t('please_select_exercise'));

            sessionSets = [];
            const lang = GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            document.getElementById('playerWorkoutTitle').innerText = (lang.startsWith('pt') && workout.namePT) ? workout.namePT : workout.name;

            let occurrenceId = 0;
            for (const itemDiv of visibleItems) {
                occurrenceId++;
                const exId = parseInt(itemDiv.dataset.id);
                const isCustom = itemDiv.dataset.iscustom === 'true';
                const ex = allExercises.find(e => e.id === exId && !!e.isCustom === isCustom);
                const workoutEx = workout.exerciseIds.find(we => {
                    const weId = typeof we === 'object' ? we.id : we;
                    const weIsCustom = typeof we === 'object' ? !!we.isCustom : false;
                    return weId === exId && weIsCustom === isCustom;
                });
                
                if (workoutEx && Array.isArray(workoutEx.sets)) {
                    workoutEx.sets.forEach((s, i) => {
                        sessionSets.push({
                            exId,
                            isCustom,
                            name: ex.name,
                            namePT: ex.namePT,
                            imageId: ex.imageId,
                            setNum: i + 1,
                            occurrenceId,
                            totalSets: workoutEx.sets.length,
                            reps: s.reps,
                            weight: s.weight,
                            completed: false,
                            skipped: false
                        });
                    });
                } else {
                    // Fallback for old structure
                    const setsCount = typeof workoutEx === 'object' ? (workoutEx.sets || 3) : 3;
                    const reps = typeof workoutEx === 'object' ? (workoutEx.reps || 0) : 0;
                    const weight = typeof workoutEx === 'object' ? (workoutEx.weight || 0) : 0;
                    for (let i = 1; i <= setsCount; i++) {
                        sessionSets.push({
                            exId,
                            isCustom,
                            name: ex.name,
                            namePT: ex.namePT,
                            imageId: ex.imageId,
                            setNum: i,
                            occurrenceId,
                            totalSets: setsCount,
                            reps,
                            weight,
                            completed: false,
                            skipped: false
                        });
                    }
                }
            }

            currentIdx = 0;
            viewingIdx = 0;
            document.getElementById('setupView').style.display = 'none';
            document.getElementById('playerView').style.display = 'block';
            const bb = document.getElementById('bottomBar'); if (bb) bb.style.display = 'flex';
            // reset routineModified state and hide the save option until user edits values
            routineModified = false;
            const saveOpt = document.getElementById('saveRoutineOpt'); if (saveOpt) saveOpt.style.display = 'none';
            // Try to keep screen awake if user enabled the setting: prefer Wake Lock API, otherwise start silent audio
            (async () => {
                try {
                    const keep = (typeof getCookie === 'function' && getCookie('gn_keep_awake') === '1');
                    if (keep) {
                        if ('wakeLock' in navigator) {
                            await requestWakeLock();
                        } else {
                            await startSilentAudio();
                        }
                    }
                } catch (err) {
                    console.warn('Could not acquire wake resources:', err);
                }
                renderSet();
            })();
        }

        // Render horizontal graph of exercise occurrences (balls + connectors)
        function renderExerciseGraph() {
            const graphEl = document.getElementById('exerciseProgressGraph');
            const countEl = document.getElementById('exerciseCompletedCount');
            if (!graphEl) return;
            graphEl.innerHTML = '';
            if (!sessionSets || sessionSets.length === 0) {
                if (countEl) countEl.innerText = '';
                return;
            }

            // Build occurrences in order and record first index for each occurrence
            const occs = [];
            const occMap = {};
            sessionSets.forEach((s, idx) => {
                if (!occMap[s.occurrenceId]) {
                    occMap[s.occurrenceId] = { occurrenceId: s.occurrenceId, startIdx: idx, sets: [], name: s.name, namePT: s.namePT };
                    occs.push(occMap[s.occurrenceId]);
                }
                occMap[s.occurrenceId].sets.push(s);
            });

            const totalOcc = occs.length;
            let completedOcc = 0;
            // Highlight the occurrence that is currently being viewed (not just the active running set)
            const activeOccId = (sessionSets[viewingIdx] && sessionSets[viewingIdx].occurrenceId) ? sessionSets[viewingIdx].occurrenceId : null;
            // Determine available width based on the title group (graph is inside it)
            const titleGroup = document.querySelector('.ex-title-group');
            let avail = graphEl.clientWidth - 8;
            if (titleGroup) {
                avail = Math.max(0, titleGroup.clientWidth - 16);
            }

            // Base dimensions (unscaled) - tuned to reduce overall width
            const baseNode = 34; // px
            const baseConn = 16; // px (reduced)
            const baseGap = 6; // px between items (reduced)
            const n = occs.length;
            const requiredWidth = n * baseNode + (n - 1) * (baseConn + baseGap);

            // Compute scale to fit inside available space; enforce a lower bound so elements remain tappable
            const scale = (requiredWidth > 0 && avail > 0) ? Math.min(1, avail / requiredWidth) : 1;
            const nodeSize = Math.max(12, Math.floor(baseNode * scale));
            const connSize = Math.max(6, Math.floor(baseConn * scale));
            const gapSize = Math.max(4, Math.floor(baseGap * scale));

            // Create an inner wrapper that will be scaled. This guarantees the whole graph is shrunk proportionally
            const wrapper = document.createElement('div');
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'center';
            wrapper.style.justifyContent = 'center';
            wrapper.style.gap = gapSize + 'px';
            wrapper.style.transformOrigin = 'center center';
            wrapper.style.willChange = 'transform';

            // Build nodes/connectors inside wrapper (unscaled sizes)
            occs.forEach((occ, i) => {
                const allDone = occ.sets.every(ss => ss.completed || ss.skipped);
                const allSkipped = occ.sets.every(ss => ss.skipped && !ss.completed);
                if (allDone) completedOcc++;

                const node = document.createElement('div');
                node.className = 'exercise-node' + (allDone ? ' completed' : '') + (allSkipped ? ' skipped' : '') + (occ.occurrenceId === activeOccId ? ' active' : '');
                node.setAttribute('role', 'button');
                node.setAttribute('tabindex', '0');
                // Accessible label for screen readers
                const labelState = allSkipped ? 'skipped' : (allDone ? 'completed' : 'pending');
                node.setAttribute('aria-label', `${i + 1} ${labelState}`);
                // Render an X for fully-skipped occurrences, a check for completed, or index otherwise
                if (allSkipped) {
                    node.innerHTML = `<span class="exercise-node-label">&#10005;</span>`; // X
                } else {
                    node.innerHTML = allDone ? `<span class="exercise-node-label">&#10003;</span>` : `<span class="exercise-node-label">${i + 1}</span>`;
                }
                node.style.width = node.style.height = baseNode + 'px';
                node.style.fontSize = '14px';
                node.addEventListener('click', () => {
                    // When user clicks a graph node, only switch the viewed exercise occurrence
                    // Do not modify `currentIdx` so the play button behaves like arrow navigation
                    viewingIdx = occ.startIdx;
                    renderSet();
                });
                node.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); node.click(); } });

                wrapper.appendChild(node);

                if (i < occs.length - 1) {
                    const conn = document.createElement('div');
                    // Keep connectors neutral regardless of node status
                    conn.className = 'exercise-connector';
                    conn.style.width = baseConn + 'px';
                    conn.style.height = '4px';
                    wrapper.appendChild(conn);
                }
            });

            // Append wrapper and apply scaling transform so the whole graph fits into 'avail'
            graphEl.appendChild(wrapper);
            const finalScale = requiredWidth > 0 ? Math.min(1, avail / requiredWidth) : 1;
            wrapper.style.transform = `scale(${finalScale})`;

            // Allow the graph to overflow slightly so nodes aren't visually cut; set a comfortable height
            graphEl.style.height = Math.ceil(baseNode * finalScale) + 12 + 'px';
            graphEl.style.overflow = 'visible';

            if (countEl) countEl.innerText = `${completedOcc}/${totalOcc}`;

            // Re-render on next animation frame to avoid measurement timing issues
            if (!window._exerciseGraphResizeAttached) {
                window._exerciseGraphResizeAttached = true;
                const schedule = () => { try { requestAnimationFrame(renderExerciseGraph); } catch (e) {} };
                window.addEventListener('resize', schedule);
                window.addEventListener('orientationchange', schedule);
            }
        }

        async function renderSet() {
            saveSessionState();
            startTimer();
            
            const progressEl = document.getElementById('progressBar');
            if (progressEl) {
                const total = sessionSets.length;
                const completed = sessionSets.filter(s => s.completed || s.skipped).length;
                progressEl.style.width = `${total > 0 ? (completed / total) * 100 : 0}%`;
            }

            // Render small exercise-progress graph (balls + connectors)
            try { renderExerciseGraph(); } catch (e) { console.warn('renderExerciseGraph error', e); }

            const viewingSet = sessionSets[viewingIdx];
            // Defensive: if viewingSet is not yet available, clear the title and bail out.
            if (!viewingSet) {
                const titleEl = document.getElementById('currentExName');
                if (titleEl) titleEl.innerText = '';
                return;
            }
            const lang = GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            const displayName = (lang.startsWith('pt') && viewingSet.namePT) ? viewingSet.namePT : viewingSet.name;
            const titleEl = document.getElementById('currentExName');
            if (titleEl) titleEl.innerText = displayName;
            
            const hasPrev = viewingSet.occurrenceId > sessionSets[0].occurrenceId;
            const hasNext = viewingSet.occurrenceId < sessionSets[sessionSets.length - 1].occurrenceId;
            document.getElementById('prevExBtn').disabled = !hasPrev;
            document.getElementById('nextExBtn').disabled = !hasNext;
            // localize navigation/tooltips
            try{
                document.getElementById('prevExBtn').title = GN_I18N.t('previous_exercise');
                document.getElementById('nextExBtn').title = GN_I18N.t('next_exercise');
                document.querySelector('.header-timer').title = GN_I18N.t('reset_timer');
            }catch(e){}

            const imgTable = viewingSet.isCustom ? db.custom_images : db.catalog_images;
            let imgSrc = defaultImage;
            if (viewingSet.imageId) {
                const imgRecord = await imgTable.get(viewingSet.imageId);
                if (imgRecord && imgRecord.data) imgSrc = imgRecord.data;
            }
            document.getElementById('playerImg').src = imgSrc; 

            // Find contiguous sets for the same exercise occurrence
            let start = viewingIdx;
            while (start > 0 && sessionSets[start - 1].occurrenceId === viewingSet.occurrenceId) start--;
            let end = viewingIdx;
            while (end < sessionSets.length - 1 && sessionSets[end + 1].occurrenceId === viewingSet.occurrenceId) end++;

            const container = document.getElementById('setsContainer');
            container.innerHTML = "";

            // Create a header row with column labels (keeps alignment with .set-row)
            const repsLabelText = (GN_I18N && GN_I18N.t) ? (GN_I18N.t('history_reps') || 'Reps') : 'Reps';
            const kgLabelText = (GN_I18N && GN_I18N.t) ? (GN_I18N.t('history_kg') || 'Kg') : 'Kg';
            const headerRow = document.createElement('div');
            headerRow.className = 'set-row header';
            headerRow.innerHTML = `
                <div class="set-label"></div>
                <div class="input-field-label">${repsLabelText}</div>
                <div class="input-field-label">${kgLabelText}</div>
            `;
            container.appendChild(headerRow);

            for (let i = start; i <= end; i++) {
                const s = sessionSets[i];
                const isActive = i === currentIdx;
                const isCompleted = s.completed;
                const isSkipped = s.skipped;
                
                const skipIcon = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" style="color:var(--danger); vertical-align:middle"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
                const checkIcon = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" style="color:var(--success); vertical-align:middle"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

                const row = document.createElement('div');
                row.className = `set-row ${isSkipped ? 'skipped' : (isCompleted ? 'completed' : '')} ${isActive ? 'active' : ''}`;
                let setsLabel;
                if (isSkipped) {
                    setsLabel = skipIcon;
                } else if (isCompleted) {
                    setsLabel = checkIcon;
                } else {
                    const fmt = (GN_I18N && typeof GN_I18N.t === 'function') ? GN_I18N.t('history_fmt_set') : 'Set {n}';
                    setsLabel = fmt.replace('{n}', s.setNum);
                }
                // Standard row: set label + reps input + kg input
                row.innerHTML = `
                    <div class="set-label">${setsLabel}</div>
                    <input type="number" value="${s.reps}" onchange="updateSetData(${i}, 'reps', this.value)" placeholder="${repsLabelText}">
                    <input type="number" step="0.5" value="${s.weight}" onchange="updateSetData(${i}, 'weight', this.value)" placeholder="${kgLabelText}">
                `;
                container.appendChild(row);
            }

            const allDone = sessionSets.every(s => s.completed || s.skipped);

            // If everything is done, show a clean finished page
            const finishedView = document.getElementById('finishedView');
            const playerViewEl = document.getElementById('playerView');
            const bottomBarEl = document.getElementById('bottomBar');
            if (allDone) {
                stopTimer();
                if (playerViewEl) playerViewEl.style.display = 'none';
                if (bottomBarEl) bottomBarEl.style.display = 'none';
                if (finishedView) {
                    finishedView.style.display = 'block';
                    // wait a frame to allow layout, then adjust illustration and show save option if needed
                    await new Promise(r => requestAnimationFrame(r));
                    updateFinishedIllustration();
                    // Show save option when session differs from the workout template or user edited values
                    try {
                        const saveOpt = document.getElementById('saveRoutineOpt');
                        const cb = document.getElementById('saveRoutineCheckbox');
                        let shouldShow = !!routineModified;
                        if (!shouldShow && currentWorkoutId) {
                            // detect differences between sessionSets and stored workout's sets
                            const workout = await db.routines.get(currentWorkoutId);
                            if (workout && Array.isArray(workout.exerciseIds)) {
                                const map = {};
                                workout.exerciseIds.forEach(it => {
                                    const id = (typeof it === 'object') ? it.id : it;
                                    if (typeof it === 'object' && Array.isArray(it.sets)) map[id] = it.sets;
                                });
                                for (const s of sessionSets) {
                                    const sets = map[s.exId];
                                    if (!sets) continue;
                                    const w = sets[s.setNum - 1];
                                    if (!w) continue;
                                    const wr = (w.reps || 0);
                                    const ww = (w.weight || 0);
                                    if ((s.reps || 0) !== wr || (s.weight || 0) !== ww) { shouldShow = true; break; }
                                }
                            }
                        }
                        if (saveOpt) saveOpt.style.display = shouldShow ? 'flex' : 'none';
                        if (cb) cb.checked = false;
                    } catch (e) { console.warn('save option detection failed', e); }
                }
                return;
            } else {
                if (finishedView) finishedView.style.display = 'none';
                if (playerViewEl) playerViewEl.style.display = 'block';
                if (bottomBarEl) bottomBarEl.style.display = 'flex';
            }

            // legacy inline finish button hidden when using finished view
            const finishBtnEl = document.getElementById('finishBtn');
            if (finishBtnEl) finishBtnEl.style.display = 'none';

            const isActiveEx = currentIdx >= start && currentIdx <= end;
            const allSetsDone = sessionSets.slice(start, end + 1).every(s => s.completed || s.skipped);

            // Toggle inline player-controls (if present)
            const pc = document.querySelector('.player-controls-icons'); if (pc) pc.classList.toggle('hidden', !isActiveEx);

            // Bottom bar controls: show prev/skip/next only when the viewed exercise is the active one.
            const bbPrev = document.getElementById('bb-prev');
            const bbSkip = document.getElementById('bb-skip');
            const bbNext = document.getElementById('bb-next');
            const actBtn = document.getElementById('activateExBtn');
            if (isActiveEx) {
                if (bbPrev) bbPrev.style.display = 'inline-flex';
                if (bbSkip) bbSkip.style.display = 'inline-flex';
                if (bbNext) bbNext.style.display = 'inline-flex';
                if (actBtn) actBtn.style.display = 'none';
            } else {
                if (bbPrev) bbPrev.style.display = 'none';
                if (bbSkip) bbSkip.style.display = 'none';
                if (bbNext) bbNext.style.display = 'none';
                if (actBtn) actBtn.style.display = (allSetsDone ? 'none' : 'inline-flex');
            }

            // Disable prev button when at the first set of the current exercise occurrence
            if (bbPrev) {
                // compute start index for the current active occurrence (based on currentIdx)
                let curStart = currentIdx;
                while (curStart > 0 && sessionSets[curStart - 1].occurrenceId === sessionSets[currentIdx].occurrenceId) curStart--;
                bbPrev.disabled = !(currentIdx > curStart);
                // visually indicate disabled state
                if (bbPrev.disabled) bbPrev.style.opacity = 0.3; else bbPrev.style.opacity = 1;
            }
        }

        function updateSetData(idx, field, value) {
            const parsed = field === 'weight' ? parseFloat(value) || 0 : parseInt(value) || 0;
            const prev = sessionSets[idx] ? sessionSets[idx][field] : undefined;
            sessionSets[idx][field] = parsed;
            // If user changed reps/weight, mark routine as modified and show the save checkbox
            if (parsed !== prev) {
                routineModified = true;
                const saveOpt = document.getElementById('saveRoutineOpt');
                if (saveOpt) saveOpt.style.display = 'flex';
                const cb = document.getElementById('saveRoutineCheckbox'); if (cb) cb.checked = false;
            }
            saveSessionState();
        }

        function nextSet() {
            sessionSets[currentIdx].completed = true;
            sessionSets[currentIdx].skipped = false;
            // After completing a set, automatically advance to the next unfinished set (wrap around)
            const next = findNextUnfinishedIndex(currentIdx);
            if (next !== -1) {
                currentIdx = next;
                viewingIdx = currentIdx;
            }
            renderSet();
        }

        function skipSet() {
            sessionSets[currentIdx].skipped = true;
            sessionSets[currentIdx].completed = false;
            // After skipping a set, automatically advance to the next unfinished set (wrap around)
            const next = findNextUnfinishedIndex(currentIdx);
            if (next !== -1) {
                currentIdx = next;
                viewingIdx = currentIdx;
            }
            renderSet();
        }

        function confirmSkipExercise() {
            const msg = GN_I18N.t('skip_exercise_confirm');
            return confirm(msg);
        }

        function abandonExercise() {
            if (!confirm(GN_I18N.t('skip_exercise_confirm'))) return;
            const currentExId = sessionSets[currentIdx].exId;
            
            // Mark all remaining sets of this exercise as skipped
            sessionSets.forEach(s => {
                if (s.exId === currentExId && !s.completed) {
                    s.skipped = true;
                }
            });

            // Move to next unfinished set overall (wrap around). If none exist, stay where we are.
            const next = findNextUnfinishedIndex(currentIdx);
            if (next !== -1) {
                currentIdx = next;
                viewingIdx = currentIdx;
            }
            renderSet();
        }

        // Find the next index of a set that is not completed or skipped, searching forward
        // from `fromIdx`. If none found after `fromIdx`, search from start up to `fromIdx` (wrap).
        // Returns -1 when there are no unfinished sets.
        function findNextUnfinishedIndex(fromIdx) {
            if (!sessionSets || sessionSets.length === 0) return -1;
            // search after current index
            for (let i = fromIdx + 1; i < sessionSets.length; i++) {
                if (!sessionSets[i].completed && !sessionSets[i].skipped) return i;
            }
            // wrap: search from beginning up to fromIdx
            for (let i = 0; i <= fromIdx; i++) {
                if (!sessionSets[i].completed && !sessionSets[i].skipped) return i;
            }
            return -1;
        }

        function prevSet() {
            if (!sessionSets || sessionSets.length === 0) return;
            // Only move back within the same exercise occurrence. Do nothing if already at the first set of this exercise.
            const curOcc = sessionSets[currentIdx].occurrenceId;
            // find first index of this occurrence
            let occStart = currentIdx;
            while (occStart > 0 && sessionSets[occStart - 1].occurrenceId === curOcc) occStart--;
            if (currentIdx > occStart) {
                currentIdx--;
                // Keep viewing focused on the active set
                viewingIdx = currentIdx;
                renderSet();
            }
        }

        function navExercise(dir) {
            const currentOcc = sessionSets[viewingIdx].occurrenceId;
            if (dir > 0) {
                let next = viewingIdx;
                while (next < sessionSets.length && sessionSets[next].occurrenceId === currentOcc) next++;
                if (next < sessionSets.length) viewingIdx = next;
            } else {
                let prev = viewingIdx;
                while (prev > 0 && sessionSets[prev - 1].occurrenceId === currentOcc) prev--;
                if (prev > 0) {
                    prev--;
                    const prevOcc = sessionSets[prev].occurrenceId;
                    while (prev > 0 && sessionSets[prev - 1].occurrenceId === prevOcc) prev--;
                    viewingIdx = prev;
                }
            }
            renderSet();
        }

        function activateExercise() {
            const occId = sessionSets[viewingIdx].occurrenceId;
            const firstIncomplete = sessionSets.findIndex(s => s.occurrenceId === occId && !s.completed && !s.skipped);
            currentIdx = firstIncomplete !== -1 ? firstIncomplete : viewingIdx;
            renderSet();
        }

        async function finishSession() {
            try {
                if (_finishingSession) return; // avoid re-entrancy
                _finishingSession = true;
                // disable finish buttons to prevent double-clicks
                const finishBtnMain = document.getElementById('finishRoutineBtn');
                const finishBtnInline = document.getElementById('finishBtn');
                if (finishBtnMain) { finishBtnMain.disabled = true; finishBtnMain.style.opacity = 0.6; }
                if (finishBtnInline) { finishBtnInline.disabled = true; finishBtnInline.style.opacity = 0.6; }

                // (no persistent session id used) ensure DB is open
                // Ensure DB is open (iOS fix for stale connections)
                await ensureDbOpen();

                const now = new Date();
                const todayStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

                // Calculate streak record before saving (Avoid uniqueKeys on iOS)
                const allLogs = await db.history.toArray();
                const existingDates = [...new Set(allLogs.map(l => l.date))].sort();
                const oldRecord = calculateStreaks(existingDates).longest;
                const newRecord = calculateStreaks([...existingDates, todayStr]).longest;

                // Update the workout template with the values used in this session only if user opted in
                const shouldSaveRoutine = (function(){ const cb = document.getElementById('saveRoutineCheckbox'); return cb ? cb.checked : false; })();
                if (shouldSaveRoutine && currentWorkoutId) {
                    const workout = await db.routines.get(currentWorkoutId);
                    if (workout) {
                        workout.exerciseIds = workout.exerciseIds.map(item => {
                            const exId = typeof item === 'object' ? item.id : item;
                            const isCustom = typeof item === 'object' ? !!item.isCustom : false;
                            const sessionExSets = sessionSets.filter(s => s.exId === exId && s.isCustom === isCustom);
                            if (sessionExSets.length > 0) {
                                return {
                                    id: exId,
                                    isCustom,
                                    sets: sessionExSets.map(s => ({ reps: s.reps, weight: s.weight }))
                                };
                            }
                            return item;
                        });
                        await db.routines.put(workout);
                    }
                }

                const logs = [];
                const groups = sessionSets.reduce((acc, s) => {
                    if (!s.completed) return acc; // Only log completed sets
                    if (!acc[s.exId]) acc[s.exId] = { ...s, count: 0 };
                    acc[s.exId].isCustom = s.isCustom;
                    acc[s.exId].count++;
                    // Use the values from the sets (last completed set values will be stored)
                    acc[s.exId].weight = s.weight;
                    acc[s.exId].reps = s.reps;
                    return acc;
                }, {});

                for (const id in groups) {
                    const g = groups[id];
                    logs.push({ exerciseId: g.exId, isCustom: g.isCustom, weight: g.weight, reps: g.reps, date: todayStr, sets: g.count });
                }

                // Persist logs (no deduplication)
                if (logs.length > 0) {
                    await db.history.bulkAdd(logs);
                }

                // Clear in-memory/active session state now that session was recorded locally
                clearSessionState();

                // Attempt to sync with Drive (with timeout). Wait for a successful sync before completing navigation.
                let syncOk = false;
                let lastSyncError = null;
                if (typeof DriveStorage !== 'undefined' && DriveStorage.sync) {
                    try {
                        try {
                            if (window.showLoading) window.showLoading((typeof GN_I18N !== 'undefined') ? GN_I18N.t('syncing_with_drive') : 'Syncing with Google Drive...');
                        } catch (e) {}

                        syncOk = await Promise.race([
                            DriveStorage.sync(db, ['logs', 'routines']),
                            new Promise((_, reject) => setTimeout(() => reject(new Error("Sync timeout")), 8000))
                        ]).then(res => !!res).catch(e => { throw e; });
                    } catch (syncErr) {
                        console.warn("Drive sync failed or timed out:", syncErr);
                        syncOk = false;
                        lastSyncError = syncErr;
                    } finally {
                        try { if (window.hideLoading) window.hideLoading(); } catch(e){}
                    }
                }

                if (!syncOk) {
                    // Mark that local changes are pending and navigate home so
                    // the existing sync-warning button is shown there. Keep the
                    // alert so the user sees the failure first.
                    try { localStorage.setItem('has_local_changes', 'true'); } catch(e){}
                    const alertMsg = (typeof GN_I18N !== 'undefined')
                        ? GN_I18N.t('sync_failed_try_home')
                        : (lastSyncError && lastSyncError.message ? lastSyncError.message : 'Sync failed - please try again.');
                    alert(alertMsg);
                    location.href = 'home.html';
                    return;
                }

                // Sync succeeded

                if (newRecord > oldRecord && newRecord > 1) {
                    const tpl = GN_I18N.t('new_streak_record');
                    alert(tpl.replace('{n}', String(newRecord)));
                }
                location.href = "statistics.html";
            } catch (err) {
                alert(GN_I18N.t('debug_error_prefix') + err.message + "\n" + err.stack);
                console.error(err);
            } finally {
                try { await releaseWakeResources(); } catch(e) { console.warn('releaseWakeResources failed in finishSession', e); }
            }
        }

        // Save only the routine template changes (update sets/reps/weights), do not log session or redirect
        async function saveRoutineChanges() {
            try {
                await ensureDbOpen();
                if (!currentWorkoutId) return alert(GN_I18N.t('no_workout_selected') || 'No workout selected');
                const workout = await db.routines.get(currentWorkoutId);
                if (!workout) return alert(GN_I18N.t('no_workout_selected') || 'No workout selected');

                workout.exerciseIds = workout.exerciseIds.map(item => {
                    const exId = typeof item === 'object' ? item.id : item;
                    const isCustom = typeof item === 'object' ? !!item.isCustom : false;
                    const sessionExSets = sessionSets.filter(s => s.exId === exId && s.isCustom === isCustom);
                    if (sessionExSets.length > 0) {
                        return {
                            id: exId,
                            isCustom,
                            sets: sessionExSets.map(s => ({ reps: s.reps, weight: s.weight }))
                        };
                    }
                    return item;
                });
                await db.routines.put(workout);
                localStorage.setItem('has_local_changes', 'true');
                alert(GN_I18N.t('routine_saved') || 'Routine saved');
            } catch (err) {
                console.error('saveRoutineChanges failed', err);
                alert(GN_I18N.t('debug_error_prefix') + err.message);
            }
        }

        init();

        // Wire fixed bottom bar buttons to existing handlers
        (function wireBottomBar(){
            const bbPrev = document.getElementById('bb-prev');
            const bbNext = document.getElementById('bb-next');
            const bbSkip = document.getElementById('bb-skip');
            if (bbPrev) bbPrev.addEventListener('click', ()=>{ try { prevSet(); } catch(e){} });
            if (bbNext) bbNext.addEventListener('click', ()=>{ try { nextSet(); } catch(e){} });
            if (bbSkip) bbSkip.addEventListener('click', ()=>{ try { skipSet(); } catch(e){} });
        })();
        </script>
        <!-- Image preview modal (full-screen) -->
        <div id="imagePreviewModal" class="image-modal hidden" onclick="hideImagePreview()">
            <div class="modal-inner" onclick="event.stopPropagation()">
                <button class="close-btn" onclick="hideImagePreview()">Ã—</button>
                <img id="imagePreviewImg" src="" alt="Preview">
            </div>
        </div>
        <script>
        function showImagePreview(src) {
            try {
                const modal = document.getElementById('imagePreviewModal');
                const img = document.getElementById('imagePreviewImg');
                if (!modal || !img) return;
                img.src = src || '';
                modal.classList.remove('hidden');
            } catch (e) { console.error(e); }
        }

        function hideImagePreview() {
            try {
                const modal = document.getElementById('imagePreviewModal');
                const img = document.getElementById('imagePreviewImg');
                if (!modal || !img) return;
                modal.classList.add('hidden');
                img.src = '';
            } catch (e) { console.error(e); }
        }
        </script>
        <script>
        // Prevent screen from sleeping using Wake Lock API, with silent-audio fallback for iOS
        let wakeLock = null;
        let audioCtx = null;
        let audioSource = null;
        let htmlSilentAudio = null;

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock was released');
                    });
                    return true;
                }
            } catch (err) {
                console.error('Wake Lock error:', err);
            }
            return false;
        }

        // Attempt to start a silent looping audio as a fallback (works on many iOS versions)
        async function startSilentAudio() {
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // create a tiny silent buffer and loop it
                if (!audioSource) {
                    const sampleRate = audioCtx.sampleRate || 44100;
                    const frameCount = sampleRate * 1; // 1 second of silence
                    const buffer = audioCtx.createBuffer(1, frameCount, sampleRate);
                    const src = audioCtx.createBufferSource();
                    src.buffer = buffer;
                    src.loop = true;
                    src.connect(audioCtx.destination);
                    src.start(0);
                    audioSource = src; 
                }
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                return true;
            } catch (err) {
                console.warn('WebAudio silent fallback failed, trying HTMLAudio element', err);
                try {
                    if (!htmlSilentAudio) {
                        htmlSilentAudio = document.createElement('audio');
                        htmlSilentAudio.loop = true;
                        // Minimal WAV silence data URI (very small)
                        htmlSilentAudio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAAA=';
                        htmlSilentAudio.volume = 0.01;
                        await htmlSilentAudio.play();
                    }
                    return true;
                } catch (e) {
                    console.warn('HTMLAudio silent fallback failed', e);
                }
            }
            return false;
        }

        function stopSilentAudio() {
            try {
                if (audioSource) {
                    try { audioSource.stop(0); } catch (e) {}
                    audioSource.disconnect();
                    audioSource = null;
                }
                if (audioCtx) {
                    try { audioCtx.close(); } catch (e) {}
                    audioCtx = null;
                }
                if (htmlSilentAudio) {
                    try { htmlSilentAudio.pause(); htmlSilentAudio.src = ''; } catch (e) {}
                    htmlSilentAudio = null;
                }
            } catch (err) {
                console.warn('Error stopping silent audio', err);
            }
        }

        // Release both wake lock and silent audio when finishing
        async function releaseWakeResources() {
            try {
                if (wakeLock) {
                    try { await wakeLock.release(); } catch (e) { console.warn('Failed to release wakeLock', e); }
                    wakeLock = null;
                }
            } catch (err) {
                console.warn('Error releasing wake lock', err);
            }
            stopSilentAudio();
        }

        // If Wake Lock API is present, keep trying to re-acquire when visibility changes
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                if ('wakeLock' in navigator) {
                    await requestWakeLock();
                }
            }
        });
        // Clean up when page is hidden or unloaded
        window.addEventListener('pagehide', () => { try { releaseWakeResources(); } catch(e){} });
        window.addEventListener('beforeunload', () => { try { releaseWakeResources(); } catch(e){} });
        </script>
        <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').then(() => console.log('Service worker registered')).catch(err => console.warn('SW registration failed', err));
        }
        </script>
</body>
</html>