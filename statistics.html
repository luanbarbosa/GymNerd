<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="color-scheme" content="only light">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#ffffff">
    <title>GymNerd | Stats</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,300,0,0" rel="stylesheet">
    <script src="auth.js"></script>
    <script src="gn-i18n.js"></script>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="db.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="styles/app-titles.css">
    <style>
        :root { 
            --primary: #3b82f6; 
            --primary-grad: linear-gradient(135deg, #60a5fa 0%, #2563eb 100%); 
            --bg: #0f172a; 
            --card: #1e293b; 
            --text: #f8fafc; 
            --text-dim: #94a3b8; 
            --success: #10b981; 
            --danger: #ef4444;
            --card-border: rgba(255, 255, 255, 0.08);
        }
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); max-width: 500px; margin: 0 auto; padding: 0; animation: fadeIn 0.3s ease-out; line-height: 1.5; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        /* Top-card (same as history) */
        .top-card { position: static; background: linear-gradient(180deg, #ffffff 0%, #ffffff 70%, #f3f4f6 100%); color: #0f172a; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; padding: 10px 16px 6px; box-shadow: 0 6px 16px rgba(2,6,23,0.06); padding-top: calc(10px + constant(safe-area-inset-top)); padding-top: calc(10px + env(safe-area-inset-top)); }
        body::before { content: ''; position: fixed; top: 0; left: 0; right: 0; height: constant(safe-area-inset-top); height: env(safe-area-inset-top); background: #ffffff; z-index: 1100; pointer-events: none; }
        .top-card-inner { max-width: 100%; display:flex; flex-direction:column; align-items:center; gap:8px; padding-bottom: 2px; }
        .app-title-compact, .top-title { margin: 20px 0; }
        .page-content { padding: 16px; padding-top: 12px; }
        .top-card .topbar { background: transparent; padding: 6px 0; display:flex; align-items:center; justify-content:space-between; width:100%; }
        #topbar-title { flex: 1; min-width: 0; display:flex; align-items:center; }
        /* Use same compact app title style as home.html */

        .back-btn { text-decoration: none; font-size: 1.5rem; color: var(--bg); }
        /* Ensure back button icons are vertically centered inside top bars */
        .top-card .back-btn, .top-card .back-btn .material-symbols-outlined { display: inline-flex; align-items: center; justify-content: center; line-height: 1; }
        
        /* Dashboard Grid */
        .stats-overview { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 24px; }
        .stat-card { background: var(--card); padding: 16px; border-radius: 20px; border: 1px solid var(--card-border); display: flex; flex-direction: column; gap: 4px; }
        .stat-label { font-size: 0.75rem; font-weight: 600; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.5rem; font-weight: 800; color: var(--text); }
        .stat-sub { font-size: 0.7rem; color: var(--text-dim); opacity: 0.8; }

        .main-grid { display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 32px; }

        .card { background: var(--card); padding: 20px; border-radius: 24px; border: 1px solid var(--card-border); box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
        .calendar-card { width: 100%; box-sizing: border-box; }
        
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .calendar-header h3 { font-size: 0.9rem; margin: 0; text-transform: capitalize; flex: 1; text-align: center; padding: 0 8px; min-width: 0; }
        /* Keep nav buttons a consistent small size and prevent flex growth that causes visual glitches on first paint */
        .nav-btn { background: rgba(255,255,255,0.05); border: none; padding: 0; width: 40px; height: 36px; min-width: 36px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; color: white; display: inline-flex; align-items: center; justify-content: center; flex: 0 0 auto; }

        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; }
        .day-name { font-size: 0.6rem; text-align: center; color: var(--text-dim); font-weight: bold; padding-bottom: 4px; }
        .calendar-day { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-size: 0.7rem; }
        
        .past-no-workout { background: rgba(239, 68, 68, 0.15); color: var(--danger); }
        .has-workout { background: var(--success); color: white; font-weight: bold; }
        .future-day { background: rgba(255,255,255,0.02); color: #475569; border: 1px solid rgba(255,255,255,0.05); }
        .today { border: 1.5px solid var(--primary); }

        .stats-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
        .section-title { margin-top: 32px; margin-bottom: 16px; font-weight: 800; font-size: 1.5rem; letter-spacing: -0.025em; background: var(--primary-grad); -webkit-background-clip: text; -webkit-text-fill-color: transparent; width: fit-content; text-transform: capitalize; grid-column: 1 / -1; }
        .chart-box { background: var(--card); padding: 20px; border-radius: 24px; border: 1px solid var(--card-border); }
        .chart-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .chart-thumb { width: 64px; height: 52px; border-radius: 8px; object-fit: contain; object-position: center; background: #fff; }
        .canvas-wrapper { height: 180px; }
        .cardio-charts { margin-top: 12px; display: flex; flex-direction: column; gap: 12px; }
        .cardio-charts .canvas-wrapper { height: 150px; }
        .exercise-group .group-header { display:flex; align-items:center; gap:8px; cursor:pointer; padding: 8px 10px; justify-content: space-between; border-radius: 8px; }
        .exercise-group .group-header:hover { background: rgba(255,255,255,0.02); }
        .exercise-group .group-header .chevron { font-size: 20px; color: var(--text-dim); margin-left: 8px; }
        .exercise-group .group-header .section-title-inline { font-weight: 800; font-size: 0.95rem; background: var(--primary-grad); -webkit-background-clip: text; -webkit-text-fill-color: transparent; flex: 1; }
        .exercise-group .group-body { display: none; margin-top: 12px; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
        .exercise-group .group-body.open { display: grid; }
        /* Radar types edit drawer */
        .radar-edit summary { list-style: none; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 10px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.04); transition: background 120ms ease, transform 120ms ease; }
        .radar-edit summary:hover { background: rgba(255,255,255,0.05); transform: translateY(-1px); }
        .radar-edit[open] summary { background: rgba(255,255,255,0.04); box-shadow: 0 6px 18px rgba(2,6,23,0.12); }
        .radar-edit summary::-webkit-details-marker { display: none; }
        .radar-edit .edit-icon { font-size: 16px; color: var(--text-dim); display:inline-flex; align-items:center; }
        .radar-edit .summary-label { font-weight: 700; color: var(--text); }
        .radar-edit #radarTypesContainer label { background: transparent; padding: 6px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); }
        .radar-edit #radarTypesContainer label:hover { background: rgba(255,255,255,0.02); }
        .radar-edit .radar-refresh-btn { margin-left: 8px; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.02); color: var(--text); cursor: pointer; font-weight: 700; font-size: 0.85rem; display: none; }
        .radar-edit .radar-refresh-btn:hover { background: rgba(255,255,255,0.035); transform: translateY(-1px); }
    </style>
</head>
<body>
    <script>
        (function(){
            try {
                const name = (location.pathname || '').split('/').pop() || '';
                if (name === 'statistics.html') {
                    const basePath = (location.pathname || '/').replace(/\/[^\/]*$/, '/') || '/';
                    const target = basePath + 'index.html?start=statistics';
                    try { location.replace(target); } catch(e) { location.href = target; }
                }
            } catch (e) {}
        })();
    </script>
    <div class="main-content">
    <div class="top-card">
        <div class="top-card-inner">
            <div style="display:flex;align-items:center;width:100%;gap:12px;">
                <div style="flex:1;min-width:0;">
                    <h2 class="app-title-compact" data-i18n="page_statistics"></h2>
                </div>
            </div>
        </div>
    </div>
    <div class="page-content">
    <div id="stats-overview" class="stats-overview"></div>

    <div id="statsEmpty" style="display:none;color:var(--text-dim);padding:20px;text-align:center;background:transparent;">
        <img src="illustrations/empty-statistics.svg" alt="" style="width:100%;max-width:100%;height:auto;margin:0 0 12px;display:block;" />
        <div data-i18n="statistics_no_history"></div>
    </div>


    <div class="main-grid">
        <div class="card calendar-card">
        <div class="calendar-header">
            <button class="nav-btn" onclick="changeMonth(-1)">❮</button>
            <h3 id="monthDisplay"></h3>
            <button class="nav-btn" onclick="changeMonth(1)">❯</button>
        </div>
        <div class="calendar-grid" id="dayNames"></div>
        <div class="calendar-grid" id="calendarGrid"></div>
        </div>

        <div class="card frequency-card">
            <div class="calendar-header">
            <h3 data-i18n="workout_frequency"></h3>
                <select id="frequencyFilter" onchange="updateFrequencyChart()" class="nav-btn" style="width: auto; border: 1px solid rgba(255,255,255,0.1);">
                <option value="month" selected data-i18n="monthly">Monthly</option>
                <option value="year" data-i18n="yearly">Yearly</option>
            </select>
        </div>
            <div class="canvas-wrapper" style="height: 200px;">
            <canvas id="frequencyChart"></canvas>
        </div>
        </div>

        
        <div class="card" id="radarCard">
            <div class="calendar-header">
                <h3 data-i18n="exercise_frequency"></h3>
                <select id="radarFilter" onchange="updateRadarChart()" class="nav-btn" style="width: auto; border: 1px solid rgba(255,255,255,0.1);">
                    <option value="all" selected data-i18n="all_time">All time</option>
                    <option value="ytd" data-i18n="year_to_date">Year to date</option>
                    <option value="6m" data-i18n="last_6_months">Last 6 months</option>
                    <option value="month" data-i18n="this_month">This month</option>
                </select>
                <!-- type selector moved below the chart to a checkbox list -->
            </div>
            <div class="canvas-wrapper" style="height: 240px;">
                <canvas id="radarChart"></canvas>
            </div>
            <details class="radar-edit" style="margin-top:12px;">
                <summary data-i18n="edit">
                    <span class="material-symbols-outlined edit-icon" aria-hidden="true">edit</span>
                    <span class="summary-label">Edit</span>
                    <button type="button" class="radar-refresh-btn" aria-label="Refresh">Refresh</button>
                </summary>
                <div id="radarTypesContainer" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px;"></div>
            </details>
        </div>
    </div>

    <div class="stats-grid" id="chartsWrapper"></div>

    <script>
        const FALLBACK_IMG = (typeof defaultImage !== 'undefined') ? defaultImage : "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM5NGFhYjgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cmVjdCB4PSIzIiB5PSIzIiB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHJ4PSIyIiByeT0iMiIvPjxjaXJjbGUgY3g9IjguNSIgY3k9IjguNSIgcj0iMS41Ii8+PHBhdGggZD0iTTIxIDE1bC01LTUtNCA0LTQtNC04IDgiLz48L3N2Zz4=";
        
        let currentViewDate = new Date();

        async function init() {
            const logs = await db.history.toArray();
            // If there is no history data, hide the stats sections but keep the top-card/topbar visible
            try {
                if (!logs || logs.length === 0) {
                    const main = document.querySelector('.main-content');
                    const empty = document.getElementById('statsEmpty');
                    if (main) {
                        // keep top-card visible
                        const top = main.querySelector('.top-card');
                        try { if (top) top.style.display = ''; } catch(e) {}

                        // hide all other children of .main-content except the top-card
                        try {
                            Array.from(main.children).forEach(ch => {
                                if (ch === top) return;
                                if (ch === empty) return;
                                ch.style.display = 'none';
                            });
                        } catch(e) {}

                        // ensure the empty placeholder is a direct child right after the top-card
                        try {
                            if (empty) {
                                main.insertBefore(empty, top.nextSibling);
                                empty.style.display = '';
                                // compute available space between bottom of top-card and top of bottom-nav
                                try {
                                    const bottomNav = document.getElementById('bottom-nav') || document.getElementById('gn-bottom-nav');
                                    const topBottom = top ? Math.ceil(top.getBoundingClientRect().bottom) : 0;
                                    const bottomHeight = bottomNav ? Math.ceil(bottomNav.getBoundingClientRect().height) : 0;
                                    const avail = Math.max(0, window.innerHeight - topBottom - bottomHeight);
                                    empty.style.display = 'flex';
                                    empty.style.flexDirection = 'column';
                                    empty.style.justifyContent = 'center';
                                    empty.style.alignItems = 'center';
                                    empty.style.height = avail + 'px';
                                    empty.style.padding = '12px 20px';
                                    empty.style.boxSizing = 'border-box';
                                    empty.style.background = 'transparent';
                                } catch (e) {}
                            }
                        } catch(e) {}
                    } else {
                        // fallback: ensure body isn't hidden entirely
                        try { document.body.style.display = ''; } catch(e) {}
                        try { if (empty) empty.style.display = ''; } catch(e) {}
                    }
                    return;
                }
                // Ensure empty placeholder hidden when data exists
            } catch (e) { /* ignore */ }
            try { const empty = document.getElementById('statsEmpty'); if (empty) empty.style.display = 'none'; } catch(e) {}
            renderCalendar(logs);
            renderCharts(logs);
            updateStreakBadge();
            updateFrequencyChart(logs);
            updateRadarChart(logs);
        }

        

        function changeMonth(offset) {
            currentViewDate.setMonth(currentViewDate.getMonth() + offset);
            init();
        }

        async function getImg(id, isCustom = false) {
            if (!id) return FALLBACK_IMG;
            const imgTable = isCustom ? db.custom_images : db.catalog_images;
            const imgRecord = await imgTable.get(id);
            return imgRecord ? imgRecord.data : FALLBACK_IMG;
        }

        function normalizeExerciseType(type) {
            const raw = (type === undefined || type === null) ? '' : String(type);
            const trimmed = raw.trim();
            const label = trimmed || 'Other';
            return {
                key: label.toLowerCase(),
                label
            };
        }

        async function renderCalendar(logs) {
            if (!logs) logs = await db.history.toArray();
            const grid = document.getElementById('calendarGrid');
            const display = document.getElementById('monthDisplay');
            const dayNamesContainer = document.getElementById('dayNames');
            const lang = GN_I18N && GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            const locale = lang === 'pt' ? 'pt' : 'en';
            // render localized short weekday names; start Monday for Portuguese
            const weekStartsOnMonday = (lang === 'pt');
            dayNamesContainer.innerHTML = '';
            const startIndex = weekStartsOnMonday ? 1 : 0; // 0 = Sunday, 1 = Monday
            for (let i = 0; i < 7; i++) {
                const dayIndex = (startIndex + i) % 7;
                // 2021-01-03 is a Sunday; add offset to get correct weekday
                const d = new Date(2021, 0, 3 + dayIndex);
                // Ensure short weekday labels are 3 letters with no trailing dot for pt
                let short = '';
                if (locale === 'pt') {
                    const ptShort = ['Dom','Seg','Ter','Qua','Qui','Sex','Sab'];
                    short = ptShort[d.getDay()];
                } else {
                    short = d.toLocaleString(locale, { weekday: 'short' }).replace(/\.$/, '');
                    if (short.length > 3) short = short.slice(0,3);
                }
                dayNamesContainer.innerHTML += `<div class="day-name">${short}</div>`;
            }
            grid.innerHTML = "";
            const year = currentViewDate.getFullYear(), month = currentViewDate.getMonth();
            const today = new Date(); today.setHours(0,0,0,0);
            display.innerText = currentViewDate.toLocaleString(locale, { month: 'long', year: 'numeric' });
            const firstDayIndex = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const workoutDates = new Set(logs.map(l => l.date));

            // Adjust first day index when week starts on Monday
            const adjustedFirstDayIndex = weekStartsOnMonday ? ((firstDayIndex + 6) % 7) : firstDayIndex;
            for (let i = 0; i < adjustedFirstDayIndex; i++) grid.innerHTML += `<div></div>`;
            for (let d = 1; d <= daysInMonth; d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                const dateObj = new Date(year, month, d);
                let status = workoutDates.has(dateStr) ? "has-workout" : (dateObj < today ? "past-no-workout" : "future-day");
                if (dateObj.getTime() === today.getTime()) status += " today";
                grid.innerHTML += `<div class="calendar-day ${status}">${d}</div>`;
            }
        }
        

        async function renderCharts(logs) {
            const renderChartsToken = (window.__gn_stats_renderChartsToken || 0) + 1;
            window.__gn_stats_renderChartsToken = renderChartsToken;
            // Prevent overlapping renders from appending duplicate groups when SPA re-initializes the page.
            const isRenderChartsStale = () => window.__gn_stats_renderChartsToken !== renderChartsToken;

            if (!logs) logs = await db.history.toArray();
            if (isRenderChartsStale()) return;
            const wrapper = document.getElementById('chartsWrapper');
            if (!wrapper) return;

            // exercise type localization is provided by GN_I18N.localizeExerciseType
            const [catalogEx, customEx] = await Promise.all([
                db.catalog_exercises.toArray(),
                db.custom_exercises.toArray()
            ]);
            if (isRenderChartsStale()) return;
            const allExercises = [
                ...catalogEx.map(ex => ({ ...ex, isCustom: false })),
                ...customEx.map(ex => ({ ...ex, isCustom: true }))
            ];
            const exMap = allExercises.reduce((acc, ex) => { acc[`${ex.id}-${!!ex.isCustom}`] = ex; return acc; }, {});

            const groupedByType = {};
            const lineDataLabelsPlugin = {
                id: 'lineDataLabels',
                afterDatasetsDraw(chart) {
                    const { ctx, data } = chart;
                    ctx.save();
                    ctx.font = 'bold 10px sans-serif';
                    ctx.fillStyle = '#94a3b8';
                    ctx.textAlign = 'center';
                    const dataset = data.datasets[0];
                    const defaultUnit = (window.GN_I18N && GN_I18N.t) ? (GN_I18N.t('history_fmt_kg_suffix') || 'kg') : 'kg';
                    const unit = (dataset && dataset.unit) ? dataset.unit : defaultUnit;
                    const meta = chart.getDatasetMeta(0);
                    const area = chart.chartArea || { left: 6, right: chart.width - 6 };
                    const minX = (area.left || 6) + 12;
                    const maxX = (area.right || (chart.width - 6)) - 12;
                    meta.data.forEach((point, index) => {
                        const value = dataset.data[index];
                        const x = Math.min(Math.max(point.x, minX), maxX);
                        ctx.fillText(value + ' ' + unit, x, point.y - 10);
                    });
                    ctx.restore();
                }
            };
            const translate = (key, fallback) => {
                if (typeof GN_I18N !== 'undefined' && typeof GN_I18N.t === 'function') {
                    try {
                        const value = GN_I18N.t(key);
                        if (value) return value;
                    } catch (e) {
                        // ignore translation errors
                    }
                }
                return fallback || '';
            };
            const safeMetricValue = (value, precision = 2) => {
                const num = Number(value);
                if (!Number.isFinite(num)) return 0;
                if (precision >= 0) return Number(num.toFixed(precision));
                return num;
            };
            const getCardioDurationValue = (entry) => {
                if (!entry) return 0;
                if (entry.duration !== undefined && entry.duration !== null) return entry.duration;
                if (entry.time !== undefined && entry.time !== null) return entry.time;
                if (entry.durationMinutes !== undefined && entry.durationMinutes !== null) return entry.durationMinutes;
                return 0;
            };
            const renderMetricChart = (canvasId, labels, values, opts = {}) => {
                const canvasEl = document.getElementById(canvasId);
                if (!canvasEl) return;
                const axisTitle = translate(opts.axisTitleKey, opts.axisTitleFallback);
                const unitText = translate(opts.unitKey, opts.unitFallback);
                new Chart(canvasEl, {
                    type: 'line',
                    plugins: [lineDataLabelsPlugin],
                    data: {
                        labels,
                        datasets: [{
                            data: values,
                            borderColor: '#3b82f6',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6',
                            pointHoverRadius: 6,
                            unit: unitText || ''
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: { padding: { left: 18, right: 18 } },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label(ctx) {
                                        const val = ctx.parsed && ctx.parsed.y !== undefined ? ctx.parsed.y : ctx.raw;
                                        return val + (unitText ? ' ' + unitText : '');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                offset: true,
                                ticks: { display: false },
                                grid: { drawBorder: false },
                                title: axisTitle ? { display: true, text: axisTitle } : { display: false }
                            },
                            y: {
                                grace: '15%',
                                grid: { color: 'rgba(255,255,255,0.05)', drawBorder: false },
                                ticks: { display: false },
                                title: { display: false }
                            }
                        }
                    }
                });
            };

            logs.forEach(l => {
                const exKey = `${l.exerciseId}-${l.isCustom !== undefined ? !!l.isCustom : l.exerciseId > 0}`;
                const ex = exMap[exKey];
                const exId = exKey;
                const typeInfo = normalizeExerciseType(ex ? ex.type : 'Other');
                if (!groupedByType[typeInfo.key]) groupedByType[typeInfo.key] = { label: typeInfo.label, exercises: {} };
                const bucket = groupedByType[typeInfo.key].exercises;
                if (!bucket[exId]) bucket[exId] = [];
                bucket[exId].push(l);
            });

            const typeEntries = Object.keys(groupedByType).map(key => {
                const entry = groupedByType[key];
                const label = entry.label || key;
                const localizedLabel = (window.GN_I18N && typeof GN_I18N.localizeExerciseType === 'function') ? (GN_I18N.localizeExerciseType(label) || label) : label;
                return { key, entry, localizedLabel };
            });
            typeEntries.sort((a, b) => {
                const left = a.localizedLabel || a.entry.label || a.key;
                const right = b.localizedLabel || b.entry.label || b.key;
                return left.localeCompare(right);
            });
            if (isRenderChartsStale()) return;

            wrapper.innerHTML = "";

            let typeIndex = 0;
            for (const typeInfo of typeEntries) {
                if (isRenderChartsStale()) return;
                const groupId = 'grp_' + (typeIndex++);
                const localizedType = typeInfo.localizedLabel || typeInfo.entry.label || typeInfo.key;

                const groupContainer = document.createElement('div');
                groupContainer.className = 'exercise-group';
                groupContainer.innerHTML = `
                    <div class="group-header" data-group="${groupId}" role="button" tabindex="0" aria-expanded="false" onclick="toggleGroup('${groupId}')" onkeydown="if(event.key==='Enter' || event.key===' ') toggleGroup('${groupId}');">
                        <div class="section-title-inline">${localizedType}</div>
                        <span class="material-symbols-outlined chevron" aria-hidden="true">expand_more</span>
                    </div>
                    <div class="group-body" id="${groupId}"></div>
                `;
                wrapper.appendChild(groupContainer);

                const exercisesInType = typeInfo.entry.exercises;
                const body = groupContainer.querySelector('.group-body');
                for (const exId of Object.keys(exercisesInType)) {
                    if (isRenderChartsStale()) return;
                    const entries = exercisesInType[exId].sort((a,b) => new Date(a.date) - new Date(b.date));
                    const lastEntry = entries[entries.length - 1];
                    const currentEx = exMap[exId];
                    const lang = GN_I18N && GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
                    const displayName = currentEx ? ((lang === 'pt' && currentEx.namePT) ? currentEx.namePT : currentEx.name) : GN_I18N.t('unknown_exercise');
                    const imgSrc = await getImg(currentEx?.imageId, currentEx?.isCustom);
                    if (isRenderChartsStale()) return;

                    const box = document.createElement('div'); 
                    box.className = 'chart-box';
                    const canvasId = `c-${lastEntry.exerciseId}-${!!lastEntry.isCustom}`.replace(/-/g, '_');
                    const isCardioType = typeInfo.key === 'cardio';
                    const chartLabels = entries.map(e => e.date.slice(5));
                    const cardioCanvasIds = {
                        distance: `${canvasId}_distance`,
                        duration: `${canvasId}_duration`
                    };
                    const chartMarkup = isCardioType ? `
                        <div class="cardio-charts">
                            <div class="canvas-wrapper"><canvas id="${cardioCanvasIds.distance}"></canvas></div>
                            <div class="canvas-wrapper"><canvas id="${cardioCanvasIds.duration}"></canvas></div>
                        </div>
                    ` : `
                        <div class="canvas-wrapper"><canvas id="${canvasId}"></canvas></div>
                    `;

                    box.innerHTML = `
                        <div class="chart-header">
                            <img src="${imgSrc}" class="chart-thumb">
                            <strong>${displayName}</strong>
                        </div>
                        ${chartMarkup}`;
                    body.appendChild(box);

                    if (isRenderChartsStale()) return;
                    if (isCardioType) {
                        const distanceValues = entries.map(e => safeMetricValue(e.distance));
                        const durationValues = entries.map(e => safeMetricValue(getCardioDurationValue(e), 0));
                        renderMetricChart(cardioCanvasIds.distance, chartLabels, distanceValues, {
                            axisTitleKey: 'cardio_distance_label',
                            axisTitleFallback: 'Distance (km)',
                            unitKey: 'cardio_distance_unit',
                            unitFallback: 'km'
                        });
                        if (isRenderChartsStale()) return;
                        renderMetricChart(cardioCanvasIds.duration, chartLabels, durationValues, {
                            axisTitleKey: 'cardio_time_label',
                            axisTitleFallback: 'Time (min)',
                            unitKey: 'cardio_time_unit',
                            unitFallback: 'min'
                        });
                    } else {
                        const weightValues = entries.map(e => {
                            const w = Number(e.weight) || 0;
                            const r = (e.reps !== undefined && e.reps !== null) ? Number(e.reps) : 1;
                            const value = r > 0 ? w / r : w;
                            return safeMetricValue(value);
                        });
                        if (isRenderChartsStale()) return;
                        renderMetricChart(canvasId, chartLabels, weightValues, {
                            axisTitleKey: 'weight_per_rep',
                            axisTitleFallback: 'Weight per rep',
                            unitKey: 'history_fmt_kg_suffix',
                            unitFallback: 'kg'
                        });
                    }

                }
            }
        }

        // Toggle function for collapsible exercise groups
        function toggleGroup(id) {
            const body = document.getElementById(id);
            const header = document.querySelector(`[data-group="${id}"]`);
            const icon = header ? header.querySelector('.chevron') : null;
            if (!body) return;
            const isOpen = body.classList.contains('open');
            if (isOpen) {
                body.classList.remove('open');
                body.style.display = 'none';
                if (icon) icon.textContent = 'expand_more';
                if (header) header.setAttribute('aria-expanded', 'false');
            } else {
                body.classList.add('open');
                body.style.display = 'grid';
                if (icon) icon.textContent = 'expand_less';
                if (header) header.setAttribute('aria-expanded', 'true');
            }
        }

        let frequencyChart = null;
        let radarChart = null;

        function getPeriodStart(period) {
            const today = new Date();
            today.setHours(0,0,0,0);
            if (period === 'all') return null;
            if (period === 'ytd') return new Date(today.getFullYear(), 0, 1);
            if (period === '6m') {
                const d = new Date(today);
                d.setMonth(d.getMonth() - 6);
                return d;
            }
            if (period === 'month') return new Date(today.getFullYear(), today.getMonth(), 1);
            return null;
        }

        // Cookie helpers for persisting radar type selection
        function setCookie(name, value, days) {
            let expires = '';
            if (days) {
                const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
                expires = '; expires=' + d.toUTCString();
            }
            document.cookie = name + '=' + encodeURIComponent(value || '') + expires + '; path=/';
        }

        function getCookie(name) {
            const nameEQ = name + '=';
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
            return null;
        }

        function saveRadarTypesToCookie(typesArray) {
            const raw = typesArray.join('|');
            setCookie('radar_types', raw, 365);
            try { localStorage.setItem('radar_types', raw); } catch (e) {}
        }

        function getSavedRadarTypes() {
            let raw = getCookie('radar_types');
            if (!raw) {
                try { raw = localStorage.getItem('radar_types'); } catch (e) { raw = null; }
            }
            if (raw === null || raw === undefined) return null;
            const arr = raw.split('|').filter(Boolean);
            return arr;
        }

        function populateRadarTypeSelector(types) {
            const container = document.getElementById('radarTypesContainer');
            if (!container) return;
            // Avoid repopulating if already filled
            if (container.childElementCount > 0) return;
            const saved = getSavedRadarTypes();
            const refreshBtn = document.querySelector('.radar-edit .radar-refresh-btn');
            if (refreshBtn) {
                try {
                    const txt = (window.GN_I18N && typeof GN_I18N.t === 'function') ? GN_I18N.t('refresh') : null;
                    if (txt) refreshBtn.innerText = txt;
                } catch (e) {}
                refreshBtn.style.display = 'none';
                refreshBtn.addEventListener('click', () => { location.reload(); });
            }
            // Sort types by their localized label so the checkboxes appear alphabetically by title
            const items = types.map(t => ({
                key: t,
                label: (window.GN_I18N && typeof GN_I18N.localizeExerciseType === 'function') ? GN_I18N.localizeExerciseType(t) : t
            }));
            items.sort((a, b) => (a.label || '').localeCompare(b.label || ''));
            items.forEach(item => {
                const t = item.key;
                const labelText = item.label;
                const id = 'rt_' + t.replace(/[^a-z0-9]+/ig, '_');
                const label = document.createElement('label');
                label.setAttribute('for', id);
                label.style.display = 'inline-flex';
                label.style.alignItems = 'center';
                label.style.gap = '6px';
                label.style.padding = '6px 8px';
                label.style.borderRadius = '8px';
                label.style.background = 'rgba(255,255,255,0.02)';
                label.style.cursor = 'pointer';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = id;
                input.value = t;
                // If saved is null => no preference saved => default to checked (show all).
                // If saved is an empty array => user explicitly saved "no types" => none checked.
                input.checked = (saved === null) ? true : (saved.length === 0 ? false : saved.includes(t));
                input.style.transform = 'scale(0.9)';
                input.addEventListener('change', () => {
                    const checked = Array.from(container.querySelectorAll('input[type=checkbox]:checked')).map(i => i.value);
                    saveRadarTypesToCookie(checked);
                    updateRadarChart();
                    if (refreshBtn) refreshBtn.style.display = 'inline-flex';
                });
                const span = document.createElement('span');
                span.innerText = labelText;
                label.appendChild(input);
                label.appendChild(span);
                container.appendChild(label);
            });
        }

        async function updateRadarChart(logs) {
            if (!logs) logs = await db.history.toArray();
            const period = document.getElementById('radarFilter').value;
            const start = getPeriodStart(period);

            const [catalogEx, customEx] = await Promise.all([
                db.catalog_exercises.toArray(),
                db.custom_exercises.toArray()
            ]);
            const allExercises = [
                ...catalogEx.map(ex => ({ ...ex, isCustom: false })),
                ...customEx.map(ex => ({ ...ex, isCustom: true }))
            ];
            const exMap = allExercises.reduce((acc, ex) => { acc[`${ex.id}-${!!ex.isCustom}`] = ex; return acc; }, {});

            const typeSet = new Set(allExercises.map(e => e.type || 'Other'));
            typeSet.add('Other');
            const types = Array.from(typeSet).sort();
            const counts = {};
            types.forEach(t => counts[t] = 0);

            logs.forEach(l => {
                if (start) {
                    const d = new Date(l.date); d.setHours(0,0,0,0);
                    if (d < start) return;
                }
                const exKey = `${l.exerciseId}-${l.isCustom !== undefined ? !!l.isCustom : l.exerciseId > 0}`;
                const ex = exMap[exKey];
                const type = ex ? ex.type : 'Other';
                counts[type] = (counts[type] || 0) + 1;
            });

            // Populate selector if needed
            populateRadarTypeSelector(types);
            // Prefer current UI checkbox state (immediate feedback) when available
            const container = document.getElementById('radarTypesContainer');
            const checkedFromUI = container ? Array.from(container.querySelectorAll('input[type=checkbox]:checked')).map(i => i.value) : null;
            const saved = getSavedRadarTypes();
            let visibleTypes = types;
            if (checkedFromUI && checkedFromUI.length > 0) {
                visibleTypes = types.filter(t => checkedFromUI.includes(t));
            } else if (saved && saved.length > 0) {
                // Fallback to cookie selection
                visibleTypes = types.filter(t => saved.includes(t));
                if (visibleTypes.length === 0) visibleTypes = types;
            }

            const labels = visibleTypes.map(t => (window.GN_I18N && typeof GN_I18N.localizeExerciseType === 'function') ? GN_I18N.localizeExerciseType(t) : t);
            const data = visibleTypes.map(t => counts[t] || 0);

            const ctx = document.getElementById('radarChart').getContext('2d');
            if (radarChart) radarChart.destroy();
            radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: 'rgba(59,130,246,0.15)',
                        borderColor: '#3b82f6',
                        borderWidth: 2,
                        pointBackgroundColor: '#3b82f6'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        r: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { display: false }
                        }
                    }
                }
            });
        }
        async function updateFrequencyChart(logs) {
            if (!logs) logs = await db.history.toArray();
            const period = document.getElementById('frequencyFilter').value;
            const lang = GN_I18N && GN_I18N.safeGetLang ? GN_I18N.safeGetLang() : 'en';
            const locale = lang === 'pt' ? 'pt' : 'en';
            const uniqueDates = [...new Set(logs.map(l => l.date))].sort();
            const counts = {};
            const today = new Date();

            if (period === 'year') {
                uniqueDates.forEach(d => {
                    const year = d.split('-')[0];
                    counts[year] = (counts[year] || 0) + 1;
                });
            } else if (period === 'month') {
                const currentYear = today.getFullYear();
                for (let i = 0; i < 12; i++) {
                    const monthName = new Date(currentYear, i, 1).toLocaleString(locale, { month: 'short' });
                    counts[monthName] = 0;
                }
                uniqueDates.forEach(d => {
                    const [y, m, day] = d.split('-').map(Number);
                    if (y === currentYear) {
                        const monthName = new Date(y, m - 1, day).toLocaleString(locale, { month: 'short' });
                        if (counts.hasOwnProperty(monthName)) counts[monthName]++;
                    }
                });
            }

            const ctx = document.getElementById('frequencyChart').getContext('2d');
            if (frequencyChart) frequencyChart.destroy();

            const barDataLabelsPlugin = {
                id: 'barDataLabels',
                afterDatasetsDraw(chart) {
                    const { ctx } = chart;
                    ctx.save();
                    ctx.font = 'bold 10px sans-serif';
                    ctx.fillStyle = '#94a3b8';
                    ctx.textAlign = 'center';
                    chart.data.datasets.forEach((dataset, i) => {
                        chart.getDatasetMeta(i).data.forEach((bar, index) => {
                            const value = dataset.data[index];
                            if (value > 0) ctx.fillText(value, bar.x, bar.y - 5);
                        });
                    });
                    ctx.restore();
                }
            };

            frequencyChart = new Chart(ctx, {
                type: 'bar',
                plugins: [barDataLabelsPlugin],
                data: {
                    labels: Object.keys(counts),
                    datasets: [{
                        data: Object.values(counts),
                        backgroundColor: 'rgba(59, 130, 246, 0.8)',
                        borderRadius: 8,
                        hoverBackgroundColor: '#3b82f6'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, grace: '15%', ticks: { stepSize: 1, color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' } },
                        x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                    }
                }
            });
        }

        async function updateStreakBadge() {
            const overview = document.getElementById('stats-overview');
            
            // Ensure DB is open (iOS fix)
            await ensureDbOpen();
            
            const allLogs = await db.history.toArray();
            const workoutDates = [...new Set(allLogs.map(l => l.date))].sort();
            
            if (workoutDates.length === 0) {
                overview.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">${GN_I18N.t('current_streak')}</div>
                        <div class="stat-value">0 <span style="font-size: 0.9rem">${GN_I18N.t('days')}</span></div>
                        <div class="stat-sub">${GN_I18N.t('start_your_journey')}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">${GN_I18N.t('best_record')}</div>
                        <div class="stat-value">0 <span style="font-size: 0.9rem">${GN_I18N.t('days')}</span></div>
                        <div class="stat-sub">${GN_I18N.t('no_records_yet')}</div>
                    </div>
                `;
                return;
            }

            const streaks = calculateStreaks(workoutDates);
            const { current, longest, daysSince } = streaks;

            overview.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">${GN_I18N.t('current_streak')}</div>
                    <div class="stat-value" style="color: ${current > 0 ? 'var(--success)' : 'var(--text)'}">
                        ${current} <span style="font-size: 0.9rem">${GN_I18N.t('days')}</span>
                    </div>
                    <div class="stat-sub">${current > 0 ? GN_I18N.t('keep_it_up') : (daysSince + ' ' + GN_I18N.t('days_since_last'))}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">${GN_I18N.t('best_record')}</div>
                    <div class="stat-value">${longest} <span style="font-size: 0.9rem">${GN_I18N.t('days')}</span></div>
                    <div class="stat-sub">${GN_I18N.t('personal_best')}</div>
                </div>
            `;
        }

        // Apply translations and localized title, then initialize
        if (window.GN_I18N) {
            try { GN_I18N.applyTranslations(document); } catch(e){}
            try { document.title = GN_I18N.t('title_main') + ' | ' + GN_I18N.t('page_statistics'); } catch(e){}
            try {
                const s = document.querySelector('.radar-edit .summary-label');
                if (s && typeof GN_I18N.t === 'function') {
                    const txt = GN_I18N.t('edit');
                    if (txt) s.innerText = txt;
                }
            } catch(e){}
        }

        init();
        </script>
        </div>
    </div>
    </body>
    </html>